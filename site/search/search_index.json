{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Effective Energy and Mass Transfer (EEMT)","text":"<p>Latest Updates</p> <p>2025-12-30: Complete documentation framework with modern data sources and parallel processing workflows</p>"},{"location":"#overview","title":"Overview","text":"<p>Effective Energy and Mass Transfer (EEMT) is a framework for quantifying energy and mass flux in Earth's Critical Zone. EEMT provides a common energy currency for understanding landscape evolution, soil formation, and biogeochemical processes across spatiotemporal scales.</p> \\[\\text{EEMT} = E_{\\text{BIO}} + E_{\\text{PPT}} \\quad \\text{[MJ m}^{-2} \\text{yr}^{-1}]\\] <p>Where: - E<sub>BIO</sub> = Energy from net primary production (biological energy) - E<sub>PPT</sub> = Energy from effective precipitation (thermal energy)</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> High Performance</p> <p>Parallel processing with GRASS GIS r.sun.mp and modern Python workflows for continental-scale analysis</p> </li> <li> <p> Public Data Integration</p> <p>Seamless integration with DAYMET, USGS 3DEP, OpenTopography, and satellite data sources</p> </li> <li> <p> Open Source</p> <p>Built entirely on open-source tools: GRASS GIS, GDAL, Python, and modern geospatial libraries</p> </li> <li> <p> Multi-Scale</p> <p>From plot-level (1m\u00b2) to continental analysis with consistent methodologies</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-install-dependencies","title":"1. Install Dependencies","text":"<pre><code># Install GRASS GIS and Python environment\nconda install -c conda-forge grass gdal rasterio xarray dask\n\n# Or use system packages\nsudo apt install grass grass-dev python3-gdal python3-rasterio\n</code></pre>"},{"location":"#2-download-data","title":"2. Download Data","text":"<pre><code># Download elevation and climate data\nfrom eemt.data_sources import download_3dep, download_daymet\n\n# Get DEM for study area\ndem_file = download_3dep([-111.0, 32.0, -110.5, 32.5], '10m')\n\n# Get climate data  \nclimate_data = download_daymet(dem_file, 2015, 2020)\n</code></pre>"},{"location":"#3-calculate-eemt","title":"3. Calculate EEMT","text":"<pre><code># Run complete EEMT workflow\nfrom eemt.workflows import calculate_eemt_topographic\n\nresult = calculate_eemt_topographic(\n    dem_file=dem_file,\n    climate_data=climate_data, \n    output_dir='eemt_results/',\n    threads=8\n)\n\nprint(f\"Mean EEMT: {result['eemt_mean']:.1f} MJ/m\u00b2/yr\")\n</code></pre>"},{"location":"#scientific-foundation","title":"Scientific Foundation","text":"<p>EEMT calculations are based on peer-reviewed methodologies:</p> Method Reference Key Innovation Traditional Rasmussen et al. (2005) Climate-based energy flux Topographic Rasmussen et al. (2014) Terrain-modified energy/water balance Vegetation Rasmussen et al. (2014) Full LAI and biomass integration HPC Implementation Swetnam et al. (2016) Parallel processing framework"},{"location":"#typical-eemt-values-by-climate-zone","title":"Typical EEMT Values by Climate Zone","text":"Arid Ecosystems 5-15 MJ/m\u00b2/yr Desert scrub, water-limited systems  Semiarid Ecosystems 15-35 MJ/m\u00b2/yr Grasslands, oak woodlands, transition zones  Humid Ecosystems 35-70 MJ/m\u00b2/yr Coniferous forests, energy-limited systems"},{"location":"#applications","title":"Applications","text":""},{"location":"#research-applications","title":"Research Applications","text":"<ul> <li>Soil formation modeling: Predict pedogenesis rates across landscapes</li> <li>Critical Zone evolution: Understand long-term landscape development  </li> <li>Biogeochemical cycling: Quantify carbon and nutrient fluxes</li> <li>Climate change impacts: Assess ecosystem sensitivity to warming</li> </ul>"},{"location":"#operational-applications","title":"Operational Applications","text":"<ul> <li>Land management: Optimize restoration and conservation strategies</li> <li>Agricultural planning: Site-specific productivity assessments</li> <li>Urban planning: Heat island mitigation and green infrastructure</li> <li>Risk assessment: Drought, fire, and erosion hazard mapping</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p> Getting Started Guide</p> <p>Installation, setup, and your first EEMT calculation</p> </li> <li> <p> Data Sources</p> <p>Access elevation and climate data from public repositories</p> </li> <li> <p> GRASS GIS Setup</p> <p>Configure parallel processing for solar radiation modeling</p> </li> <li> <p>:material-workflow: Calculation Methods</p> <p>Step-by-step workflows for all three EEMT approaches</p> </li> </ul>"},{"location":"#community","title":"Community","text":""},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to improve EEMT methods, add new examples, and extend functionality. See our Development Guide.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>Discussions: Ask scientific methodology questions</li> <li>Examples: Share use cases and workflows</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use EEMT in your research, please cite:</p> <p>Primary Citation</p> <p>Rasmussen, C., Pelletier, J.D., Troch, P.A., Swetnam, T.L., and Chorover, J. (2015). Quantifying topographic and vegetation effects on the transfer of energy and mass to the critical zone. Vadose Zone Journal, 14(1). doi:10.2136/vzj2014.07.0102</p> <p>For high-performance computing implementations:</p> <p>HPC Citation</p> <p>Swetnam, T.L., Pelletier, J.D., Rasmussen, C., Callahan, N.R., Merchant, N., and Lyons, E. (2016). Scaling GIS analysis tasks from the desktop to the cloud utilizing contemporary distributed computing and data management approaches. Proceedings of XSEDE16. doi:10.1145/2949550.2949573</p> <p> EEMT is developed and maintained by the Critical Zone Observatory community Advancing understanding of Earth's Critical Zone through quantitative energy analysis </p>"},{"location":"PLAN/","title":"EEMT Modernization Plan (2025)","text":""},{"location":"PLAN/#overview","title":"Overview","text":"<p>This plan outlines the modernization of the Effective Energy and Mass Transfer (EEMT) algorithm suite, transitioning from 2016-era implementations to leverage contemporary geospatial software advances and cloud-native computing paradigms.</p>"},{"location":"PLAN/#current-state-assessment","title":"Current State Assessment","text":""},{"location":"PLAN/#legacy-system-2016","title":"Legacy System (2016)","text":"<ul> <li>GRASS GIS: Version 6.x/7.x (current: 8.x available)</li> <li>GDAL: Version 1.x (current: 3.8+)</li> <li>PROJ: Version 4.x (current: 9.x with enhanced datum transformations)</li> <li>Workflow Engine: CCTools Makeflow + Work Queue</li> <li>Computing Environment: OpenScienceGrid, XSEDE HPC clusters</li> <li>Container Technology: Docker (basic implementation)</li> <li>Language: Python 2.x, Bash scripts</li> </ul>"},{"location":"PLAN/#technical-debt-identified","title":"Technical Debt Identified","text":"<ol> <li>Python 2.x deprecation: End-of-life compatibility issues</li> <li>Hardcoded OpenScienceGrid URLs: Broken data access endpoints</li> <li>SAGA-GIS dependencies: Planned deprecation in favor of GRASS-native tools</li> <li>Legacy projection handling: Pre-PROJ 6.x datum transformations</li> <li>Manual DAYMET downloads: No API integration for automated data access</li> </ol>"},{"location":"PLAN/#modernization-objectives","title":"Modernization Objectives","text":""},{"location":"PLAN/#phase-1-foundation-modernization-q1-2025","title":"Phase 1: Foundation Modernization (Q1 2025)","text":""},{"location":"PLAN/#software-stack-updates","title":"Software Stack Updates","text":"<ul> <li>Python 3.12+: Full migration with type hints and async support</li> <li>GRASS GIS 8.4+: Latest LTS with enhanced parallelization</li> <li>GDAL 3.8+: Modern format support and cloud-optimized GeoTIFF</li> <li>PROJ 9.x: Enhanced coordinate reference system handling</li> <li>QGIS 3.34+ LTR: Integration for processing algorithm development</li> </ul>"},{"location":"PLAN/#container-modernization","title":"Container Modernization","text":"<ul> <li>Apptainer/Singularity: Replace Docker for HPC compatibility</li> <li>Multi-stage builds: Optimize container size and security</li> <li>Base images: Official OSGEO/GDAL containers as foundation</li> </ul>"},{"location":"PLAN/#code-quality-improvements","title":"Code Quality Improvements","text":"<ul> <li>Type annotations: Full Python typing for better maintainability</li> <li>Error handling: Comprehensive exception management</li> <li>Logging: Structured logging with configurable levels</li> <li>Testing: Unit and integration test suites</li> <li>Documentation: API docs with Sphinx</li> </ul>"},{"location":"PLAN/#phase-2-data-infrastructure-modernization-q2-2025","title":"Phase 2: Data Infrastructure Modernization (Q2 2025)","text":""},{"location":"PLAN/#cloud-optimized-data-access","title":"Cloud-Optimized Data Access","text":"<ul> <li>STAC (SpatioTemporal Asset Catalog): Standardized metadata</li> <li>Cloud-Optimized GeoTIFF (COG): Efficient remote data access</li> <li>Zarr arrays: Chunked, compressed multi-dimensional data</li> <li>Dask integration: Parallel processing of large datasets</li> </ul>"},{"location":"PLAN/#daymet-api-integration","title":"DAYMET API Integration","text":"<ul> <li>ORNL DAAC API: Direct programmatic access to DAYMET v4</li> <li>Temporal subsetting: On-demand date range queries</li> <li>Spatial subsetting: Bounding box and geometry-based filtering</li> <li>Format optimization: NetCDF4/Zarr for time series analysis</li> </ul>"},{"location":"PLAN/#alternative-climate-datasets","title":"Alternative Climate Datasets","text":"<ul> <li>PRISM: High-resolution precipitation and temperature (US)</li> <li>ERA5: Global reanalysis data via Climate Data Store</li> <li>CHIRPS: Global precipitation (focus on data-sparse regions)</li> <li>TerraClimate: Monthly global climate data</li> </ul>"},{"location":"PLAN/#phase-3-algorithm-enhancement-q3-2025","title":"Phase 3: Algorithm Enhancement (Q3 2025)","text":""},{"location":"PLAN/#grass-gis-8x-features","title":"GRASS GIS 8.x Features","text":"<ul> <li>r.sun.mp: Enhanced multi-core solar radiation modeling</li> <li>r.sim.water: Improved overland flow simulation</li> <li>r.stream.extract: Modern drainage network delineation</li> <li>r.slope.aspect: Vectorized slope/aspect calculations</li> <li>Temporal framework: Built-in time series management</li> </ul>"},{"location":"PLAN/#gpu-acceleration","title":"GPU Acceleration","text":"<ul> <li>RAPIDS cuSpatial: GPU-accelerated geospatial operations</li> <li>r.sun OpenCL: GPU solar radiation calculations</li> <li>CuPy arrays: NumPy-compatible GPU computations</li> <li>Numba CUDA: Just-in-time GPU kernel compilation</li> </ul>"},{"location":"PLAN/#advanced-topographic-analysis","title":"Advanced Topographic Analysis","text":"<ul> <li>Multiscale terrain analysis: Automated scale-dependent metrics</li> <li>Geomorphons: Landform classification integration</li> <li>Flow accumulation algorithms: Multiple flow direction methods</li> <li>Landscape connectivity: Graph-based terrain analysis</li> </ul>"},{"location":"PLAN/#phase-4-workflow-modernization-q4-2025","title":"Phase 4: Workflow Modernization (Q4 2025)","text":""},{"location":"PLAN/#workflow-engines","title":"Workflow Engines","text":"<ul> <li>Apache Airflow: Modern DAG-based workflow management</li> <li>Nextflow: Scientific workflow engine with container support</li> <li>Snakemake: Python-based workflow management</li> <li>CWL (Common Workflow Language): Portable workflow descriptions</li> </ul>"},{"location":"PLAN/#cloud-native-computing","title":"Cloud-Native Computing","text":"<ul> <li>Kubernetes: Container orchestration for scalable deployments</li> <li>Dask Gateway: Distributed computing on cloud infrastructure</li> <li>JupyterHub: Collaborative notebook environments</li> <li>Pangeo ecosystem: Cloud-based earth science computing stack</li> </ul>"},{"location":"PLAN/#hpc-integration","title":"HPC Integration","text":"<ul> <li>SLURM: Modern batch scheduler integration</li> <li>LSF/PBS: Legacy HPC system compatibility</li> <li>Flux Framework: Next-generation resource management</li> <li>Charliecloud: HPC-friendly container runtime</li> </ul>"},{"location":"PLAN/#new-capabilities-and-features","title":"New Capabilities and Features","text":""},{"location":"PLAN/#enhanced-spatial-analysis","title":"Enhanced Spatial Analysis","text":"<ol> <li>Multi-resolution processing: Adaptive grid refinement</li> <li>Uncertainty quantification: Monte Carlo error propagation</li> <li>Machine learning integration: RF/XGBoost for parameter estimation</li> <li>Change detection: Temporal trend analysis capabilities</li> </ol>"},{"location":"PLAN/#improved-climate-integration","title":"Improved Climate Integration","text":"<ol> <li>Climate scenarios: RCP/SSP future projections</li> <li>Bias correction: Statistical downscaling methods</li> <li>Extreme events: Return period analysis</li> <li>Seasonal decomposition: Trend/seasonal/residual components</li> </ol>"},{"location":"PLAN/#advanced-visualization","title":"Advanced Visualization","text":"<ol> <li>Interactive dashboards: Streamlit/Dash applications</li> <li>Time series visualization: Plotly/Bokeh temporal plots</li> <li>3D terrain rendering: PyVista/Mayavi landscape views</li> <li>Web mapping: Folium/Leaflet interactive maps</li> </ol>"},{"location":"PLAN/#public-dataset-integration","title":"Public Dataset Integration","text":""},{"location":"PLAN/#high-resolution-topography","title":"High-Resolution Topography","text":"<ul> <li>3DEP (USGS): 1-meter resolution US-wide lidar coverage</li> <li>FABDEM: Forest-corrected global 30m elevation</li> <li>COP-DEM: Copernicus 30/90m global elevation</li> <li>OpenTopography: On-demand lidar data access</li> </ul>"},{"location":"PLAN/#climate-and-environmental-data","title":"Climate and Environmental Data","text":"<ul> <li>GridMET: High-resolution meteorological data (US)</li> <li>Landsat Collection 2: 50-year earth observation archive</li> <li>Sentinel-2: High-resolution multispectral imagery (5-day revisit)</li> <li>MODIS: Long-term vegetation and land surface datasets</li> </ul>"},{"location":"PLAN/#derived-products","title":"Derived Products","text":"<ul> <li>Global Forest Change: Annual forest loss/gain (2000-present)</li> <li>ESA WorldCover: 10m global land cover classification</li> <li>USGS GAP: Vegetation and species distribution (US)</li> <li>SoilGrids: Global soil property predictions</li> </ul>"},{"location":"PLAN/#claudemd-implementation","title":"CLAUDE.md Implementation","text":""},{"location":"PLAN/#purpose","title":"Purpose","text":"<p>A configuration file to guide Claude Code assistant in understanding the modernized EEMT codebase structure and computational requirements.</p>"},{"location":"PLAN/#key-contents","title":"Key Contents","text":"<pre><code>project_type: geospatial_modeling\nlanguage: python\nversion: \"3.12+\"\ndependencies:\n  - grass-gis&gt;=8.4\n  - gdal&gt;=3.8\n  - rasterio&gt;=1.3\n  - xarray&gt;=2024.1\n  - dask&gt;=2024.1\n  - geopandas&gt;=0.14\n\ntest_commands:\n  - \"pytest tests/\"\n  - \"grass --version\"\n  - \"gdalinfo --version\"\n\ncompute_requirements:\n  memory_per_thread: \"2GB\"\n  threads_default: 4\n  gpu_optional: true\n\ndata_sources:\n  - \"ORNL DAAC DAYMET API\"\n  - \"USGS 3DEP elevation\"\n  - \"User-provided DEM files\"\n\nworkflow_engines:\n  - \"Nextflow (preferred)\"\n  - \"Apache Airflow\"\n  - \"Dask Distributed\"\n</code></pre>"},{"location":"PLAN/#implementation-timeline","title":"Implementation Timeline","text":""},{"location":"PLAN/#2025-milestones","title":"2025 Milestones","text":"<ul> <li>Q1: Foundation modernization complete</li> <li>Q2: Cloud data infrastructure operational  </li> <li>Q3: Enhanced algorithms tested and benchmarked</li> <li>Q4: Modern workflow system deployed</li> </ul>"},{"location":"PLAN/#success-metrics","title":"Success Metrics","text":"<ul> <li>Performance: 5x speedup through GPU acceleration</li> <li>Scalability: Process continental-scale datasets</li> <li>Reliability: 99%+ workflow success rate</li> <li>Accessibility: Cloud deployment reduces barrier to entry</li> <li>Sustainability: Active community contribution model</li> </ul>"},{"location":"PLAN/#risk-mitigation","title":"Risk Mitigation","text":""},{"location":"PLAN/#technical-risks","title":"Technical Risks","text":"<ol> <li>GPU availability: Fallback to CPU implementations</li> <li>Data access failures: Local caching and alternative sources</li> <li>Version compatibility: Comprehensive testing matrix</li> <li>Performance regression: Benchmark-driven development</li> </ol>"},{"location":"PLAN/#resource-risks","title":"Resource Risks","text":"<ol> <li>Compute costs: Efficient algorithms and resource monitoring</li> <li>Storage requirements: Compression and data lifecycle policies</li> <li>Network bandwidth: Edge computing and data locality</li> </ol>"},{"location":"PLAN/#community-engagement","title":"Community Engagement","text":""},{"location":"PLAN/#open-source-strategy","title":"Open Source Strategy","text":"<ul> <li>GitHub: Public development with issue tracking</li> <li>Documentation: Comprehensive user guides and tutorials</li> <li>Examples: Jupyter notebooks for common use cases</li> <li>Workshops: Virtual training sessions</li> </ul>"},{"location":"PLAN/#academic-partnerships","title":"Academic Partnerships","text":"<ul> <li>CZO Network: Critical Zone Observatory collaboration</li> <li>OpenTopography: Processing pipeline integration</li> <li>CUAHSI: Hydrology informatics community engagement</li> <li>AGU/ESA: Conference presentations and workshops</li> </ul> <p>This modernization plan positions EEMT for the next decade of geospatial computing while maintaining scientific rigor and expanding accessibility to the broader earth science community.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior:</p> <ul> <li>The use of sexualized language or imagery</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Project maintainers are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at tswetnam@cyverse.org.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0.</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#software-license","title":"Software License","text":"<p>The EEMT software framework is released under the MIT License.</p> <pre><code>MIT License\n\nCopyright (c) 2025 Tyson L. Swetnam and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#documentation-license","title":"Documentation License","text":"<p>This documentation is licensed under Creative Commons Attribution 4.0 International (CC BY 4.0).</p> <p>You are free to: - Share \u2014 copy and redistribute the material in any medium or format - Adapt \u2014 remix, transform, and build upon the material for any purpose</p> <p>Under the following terms: - Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made.</p>"},{"location":"license/#data-licenses","title":"Data Licenses","text":""},{"location":"license/#public-domain-data","title":"Public Domain Data","text":"<ul> <li>USGS 3DEP elevation data: Public domain</li> <li>DAYMET climate data: Public domain (US Government work)</li> <li>Landsat satellite imagery: Public domain (US Government work)</li> </ul>"},{"location":"license/#third-party-data","title":"Third-Party Data","text":"<ul> <li>PRISM climate data: Oregon State University, usage restrictions may apply</li> <li>OpenTopography data: Various licenses depending on data source</li> <li>MODIS products: NASA public domain with attribution requirements</li> </ul>"},{"location":"license/#citation-requirements","title":"Citation Requirements","text":"<p>If you use EEMT in your research, please cite the appropriate methodological papers:</p>"},{"location":"license/#primary-citation","title":"Primary Citation","text":"<pre><code>@article{rasmussen2015quantifying,\n  title={Quantifying topographic and vegetation effects on the transfer of energy and mass to the critical zone},\n  author={Rasmussen, Craig and Pelletier, Jon D and Troch, Peter A and Swetnam, Tyson L and Chorover, Jon},\n  journal={Vadose Zone Journal},\n  volume={14},\n  number={1},\n  year={2015},\n  publisher={Soil Science Society of America},\n  doi={10.2136/vzj2014.07.0102}\n}\n</code></pre>"},{"location":"license/#software-citation","title":"Software Citation","text":"<pre><code>@software{eemt_software_2025,\n  title={EEMT: Effective Energy and Mass Transfer Calculation Framework},\n  author={Swetnam, Tyson L. and Rasmussen, Craig and Pelletier, Jon D.},\n  year={2025},\n  url={https://github.com/tyson-swetnam/eemt},\n  version={2025.1}\n}\n</code></pre>"},{"location":"license/#third-party-licenses","title":"Third-Party Licenses","text":""},{"location":"license/#grass-gis","title":"GRASS GIS","text":"<p>GNU General Public License v2.0 or later https://grass.osgeo.org/about/license/</p>"},{"location":"license/#gdalogr","title":"GDAL/OGR","text":"<p>MIT/X11 License https://gdal.org/license.html</p>"},{"location":"license/#python-scientific-stack","title":"Python Scientific Stack","text":"<p>Various open source licenses (BSD, MIT, Apache 2.0)</p>"},{"location":"license/#contributing","title":"Contributing","text":"<p>By contributing to this project, you agree that your contributions will be licensed under the same terms as the project (MIT License for code, CC BY 4.0 for documentation).</p> <p>See Development Guide for more information.</p>"},{"location":"about/","title":"About EEMT","text":""},{"location":"about/#project-history","title":"Project History","text":"<p>The Effective Energy and Mass Transfer (EEMT) framework was developed by the Critical Zone Observatory community to provide a quantitative approach for understanding energy and mass flux in Earth's Critical Zone.</p>"},{"location":"about/#timeline","title":"Timeline","text":"<p>2005: Initial EEMT framework developed by Rasmussen et al. 2011: Open system thermodynamics integration (Rasmussen et al.) 2014: Topographic and vegetation effects quantified (Rasmussen et al.) 2016: High-performance computing implementation (Swetnam et al.) 2025: Modern data infrastructure and cloud computing integration</p>"},{"location":"about/#core-principles","title":"Core Principles","text":""},{"location":"about/#open-science","title":"Open Science","text":"<ul> <li>All code is open source and freely available</li> <li>Methods are peer-reviewed and reproducible</li> <li>Data sources are publicly accessible</li> <li>Results are validated against field measurements</li> </ul>"},{"location":"about/#fair-data-principles","title":"FAIR Data Principles","text":"<ul> <li>Findable: Comprehensive metadata and documentation</li> <li>Accessible: Public repositories and APIs</li> <li>Interoperable: Standard formats and protocols</li> <li>Reusable: Clear licensing and attribution</li> </ul>"},{"location":"about/#community-driven-development","title":"Community-Driven Development","text":"<ul> <li>Collaborative development model</li> <li>Multiple institutional partnerships</li> <li>Student training and education</li> <li>International research network</li> </ul>"},{"location":"about/#technical-philosophy","title":"Technical Philosophy","text":""},{"location":"about/#energy-based-framework","title":"Energy-Based Framework","text":"<p>EEMT uses energy flux as a common currency to integrate: - Solar radiation and climate processes - Biological productivity and carbon cycling - Hydrologic partitioning and water balance - Geomorphologic processes and landscape evolution</p>"},{"location":"about/#scale-integration","title":"Scale Integration","text":"<p>From local processes to continental patterns: - Plot scale: 1-100 m\u00b2 detailed process studies - Hillslope scale: 0.01-1 km\u00b2 terrain effects - Catchment scale: 1-1000 km\u00b2 watershed analysis - Regional scale: &gt;1000 km\u00b2 climate gradient studies</p>"},{"location":"about/#temporal-integration","title":"Temporal Integration","text":"<p>From daily variations to millennial trends: - Daily: Solar radiation and weather processes - Monthly: Vegetation growth and seasonal patterns - Annual: Climate averages and interannual variability - Decadal: Long-term trends and climate change - Centennial: Landscape evolution and soil formation</p>"},{"location":"about/publications/","title":"Publications","text":""},{"location":"about/publications/#primary-eemt-publications","title":"Primary EEMT Publications","text":""},{"location":"about/publications/#foundational-papers","title":"Foundational Papers","text":"<p>Core Methodology</p> <p>Rasmussen, C., Southard, R.J., and Horwath, W.R. (2005). Modeling energy inputs to predict pedogenic environments using regional environmental databases. Soil Science Society of America Journal, 69(4), 1266-1274. doi:10.2136/sssaj2003.0283</p> <p>Thermodynamic Framework</p> <p>Rasmussen, C., Troch, P.A., Chorover, J., Brooks, P., Pelletier, J., and Huxman, T.E. (2011). An open system framework for integrating critical zone structure and function. Biogeochemistry, 102(1-3), 15-29. doi:10.1007/s10533-010-9476-8</p> <p>Topographic and Vegetation Effects</p> <p>Rasmussen, C., Pelletier, J.D., Troch, P.A., Swetnam, T.L., and Chorover, J. (2015). Quantifying topographic and vegetation effects on the transfer of energy and mass to the critical zone. Vadose Zone Journal, 14(1). doi:10.2136/vzj2014.07.0102</p> <p>High-Performance Computing</p> <p>Swetnam, T.L., Pelletier, J.D., Rasmussen, C., Callahan, N.R., Merchant, N., and Lyons, E. (2016). Scaling GIS analysis tasks from the desktop to the cloud utilizing contemporary distributed computing and data management approaches. Proceedings of XSEDE16. doi:10.1145/2949550.2949573</p>"},{"location":"about/publications/#comparative-studies","title":"Comparative Studies","text":"<p>Rasmussen, C. and Gallo, E.L. (2013). Technical Note: A comparison of model and empirical measures of catchment-scale effective energy and mass transfer. Hydrology and Earth System Sciences, 17(9), 3389-3395. doi:10.5194/hess-17-3389-2013</p> <p>Rasmussen, C. and Tabor, N.J. (2007). Applying a quantitative pedogenic energy model across a range of environmental gradients. Soil Science Society of America Journal, 71(6), 1719-1729. doi:10.2136/sssaj2007.0051</p>"},{"location":"about/publications/#applications-and-case-studies","title":"Applications and Case Studies","text":""},{"location":"about/publications/#landscape-evolution","title":"Landscape Evolution","text":"<p>Pelletier, J.D., Barron-Gafford, G.A., Breshears, D.D., Brooks, P.D., Chorover, J., Durcik, M., et al. (2013). Coevolution of nonlinear trends in vegetation, soils, and topography with elevation and slope aspect: A case study in the sky islands of southern Arizona. Journal of Geophysical Research: Earth Surface, 118(2), 741-758. doi:10.1002/jgrf.20046</p> <p>Zapata-R\u00edos, X., Brooks, P.D., Troch, P.A., McIntosh, J., and Guo, Q. (2016). Influence of terrain aspect on water partitioning, vegetation structure and vegetation greening in high-elevation catchments in northern New Mexico. Ecohydrology, 9(6), 1073-1083. doi:10.1002/eco.1711</p>"},{"location":"about/publications/#critical-zone-science","title":"Critical Zone Science","text":"<p>Chorover, J., Troch, P.A., Rasmussen, C., Brooks, P.D., Pelletier, J.D., Breshears, D.D., et al. (2011). How water, carbon, and energy drive critical zone evolution: The Jemez\u2013Santa Catalina Critical Zone Observatory. Vadose Zone Journal, 10(3), 884-899. doi:10.2136/vzj2010.0132</p> <p>Lybrand, R.A. and Rasmussen, C. (2014). Linking soil element-mass-transfer to microscale mineral weathering across a semiarid environmental gradient. Chemical Geology, 381, 26-39. doi:10.1016/j.chemgeo.2014.04.022</p>"},{"location":"about/publications/#computational-advances","title":"Computational Advances","text":"<p>Swetnam, T.L. (2013). Cordilleran forest scaling dynamics and disturbance regimes quantified by aerial LiDAR. Ph.D. Dissertation, University of Arizona, Tucson. Link</p> <p>Callahan, N.R., Merchant, N., Young, K., Rynge, M., Swetnam, T.L., and Lyons, E. (2015). Application of distributed computing and data cyberinfrastructure for enabling large-scale collaborative research. Concurrency and Computation: Practice and Experience, 27(2), 328-343. doi:10.1002/cpe.3228</p>"},{"location":"about/publications/#theses-and-dissertations","title":"Theses and Dissertations","text":""},{"location":"about/publications/#doctoral-dissertations","title":"Doctoral Dissertations","text":"<p>Swetnam, T.L. (2013). Cordilleran forest scaling dynamics and disturbance regimes quantified by aerial LiDAR. University of Arizona.</p> <p>Holleran, M.E. (2013). Quantifying catchment scale soil variability in Marshall Gulch, Santa Catalina Mountains Critical Zone Observatory. University of Arizona.</p>"},{"location":"about/publications/#masters-theses","title":"Master's Theses","text":"<p>Lybrand, R.A. (2011). Climate and landscape controls on soil development across semiarid-subhumid environmental gradients. University of Arizona.</p> <p>Durcik, M. (2010). The role of climate and vegetation in regulating soil formation in the Santa Catalina Mountains. University of Arizona.</p>"},{"location":"about/publications/#conference-presentations","title":"Conference Presentations","text":""},{"location":"about/publications/#recent-presentations-2020-2025","title":"Recent Presentations (2020-2025)","text":"<ul> <li>American Geophysical Union Fall Meeting (2024): \"Modernizing EEMT calculations for cloud-native earth system analysis\"</li> <li>Soil Science Society of America Annual Meeting (2023): \"Continental-scale EEMT patterns and climate sensitivity\"</li> <li>International Association of Geomorphologists (2022): \"Energy-based landscape evolution modeling\"</li> </ul>"},{"location":"about/publications/#historical-presentations-2010-2020","title":"Historical Presentations (2010-2020)","text":"<ul> <li>XSEDE16 Conference (2016): Scaling GIS analysis from desktop to cloud</li> <li>Critical Zone Observatory All Hands Meeting (2015): EEMT applications across CZO network</li> <li>American Geophysical Union Fall Meeting (2014): Topographic controls on Critical Zone energy flux</li> <li>Soil Science Society of America Annual Meeting (2013): Comparative EEMT methodology validation</li> </ul>"},{"location":"about/publications/#related-research","title":"Related Research","text":""},{"location":"about/publications/#critical-zone-observatory-network","title":"Critical Zone Observatory Network","text":"<p>The EEMT framework has been applied across multiple Critical Zone Observatory sites:</p> <ul> <li>Santa Catalina Mountains-Jemez River Basin CZO (Arizona/New Mexico)</li> <li>Boulder Creek CZO (Colorado)  </li> <li>Luquillo CZO (Puerto Rico)</li> <li>Southern Sierra CZO (California)</li> <li>Christina River Basin CZO (Delaware/Pennsylvania)</li> </ul>"},{"location":"about/publications/#international-collaborations","title":"International Collaborations","text":"<p>European Critical Zone Network: EEMT methodology adaptation for European ecosystems</p> <p>Australian Critical Zone Network: Application to unique Australian landscapes and climate gradients</p> <p>Chinese Academy of Sciences: EEMT applications in Tibetan Plateau research</p>"},{"location":"about/publications/#software-citations","title":"Software Citations","text":""},{"location":"about/publications/#primary-software","title":"Primary Software","text":"<p>When using the EEMT software framework, please cite:</p> <pre><code>@software{eemt_framework_2025,\n  title = {EEMT: Effective Energy and Mass Transfer Calculation Framework},\n  author = {Swetnam, Tyson L. and Rasmussen, Craig and Pelletier, Jon D.},\n  year = {2025},\n  url = {https://github.com/tyson-swetnam/eemt},\n  version = {2025.1},\n  doi = {10.5281/zenodo.XXXXXX}\n}\n</code></pre>"},{"location":"about/publications/#dependent-software","title":"Dependent Software","text":"<p>EEMT builds upon these key software packages:</p> <ul> <li>GRASS GIS: Neteler, M. and Mitasova, H. (2008). Open Source GIS: A GRASS GIS Approach. Springer, New York.</li> <li>GDAL: GDAL/OGR contributors (2025). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation.</li> <li>CCTools: Bui, P., et al. (2011). Work Queue + Python: A Framework For Scalable Scientific Ensemble Applications.</li> </ul>"},{"location":"about/publications/#data-citations","title":"Data Citations","text":""},{"location":"about/publications/#climate-data","title":"Climate Data","text":"<p>DAYMET: Thornton, M.M., et al. (2022). Daymet: Daily Surface Weather Data on a 1-km Grid for North America, Version 4 R1. ORNL DAAC, Oak Ridge, Tennessee, USA. doi:10.3334/ORNLDAAC/2129</p> <p>PRISM: PRISM Climate Group (2023). PRISM Climate Data. Oregon State University. http://prism.oregonstate.edu</p>"},{"location":"about/publications/#elevation-data","title":"Elevation Data","text":"<p>USGS 3DEP: U.S. Geological Survey (2023). 3D Elevation Program. https://www.usgs.gov/3d-elevation-program</p> <p>OpenTopography: OpenTopography Facility (2023). High-Resolution Topography Data and Tools. doi:10.5069/G9Z8944F</p>"},{"location":"about/publications/#acknowledgments","title":"Acknowledgments","text":""},{"location":"about/publications/#funding-agencies","title":"Funding Agencies","text":"<ul> <li>National Science Foundation: Critical Zone Observatory Program (EAR-0724958, EAR-1331408)</li> <li>National Science Foundation: XSEDE Extended Collaborative Support Service (ACI-1053575)</li> <li>Department of Energy: Environmental System Science Program</li> <li>USDA Forest Service: Forest and Rangeland Ecosystem Science Center</li> </ul>"},{"location":"about/publications/#institutional-support","title":"Institutional Support","text":"<ul> <li>University of Arizona: Department of Soil, Water and Environmental Science</li> <li>University of Arizona: Department of Geosciences  </li> <li>University of Arizona: Department of Hydrology and Water Resources</li> <li>CyVerse: Cyberinfrastructure for biological research</li> <li>XSEDE: Extreme Science and Engineering Discovery Environment</li> </ul>"},{"location":"about/publications/#computational-resources","title":"Computational Resources","text":"<ul> <li>Open Science Grid: Distributed high-throughput computing</li> <li>SDSC Comet: High-performance computing resources</li> <li>University of Arizona HPC: Local computational support</li> <li>NCAR-Wyoming Supercomputing Center: Climate modeling resources</li> </ul> <p>For complete acknowledgments and detailed attribution, see individual publication acknowledgment sections.</p>"},{"location":"api-reference/","title":"EEMT API Reference","text":""},{"location":"api-reference/#overview","title":"Overview","text":"<p>This reference provides detailed documentation for all EEMT calculation functions, GRASS GIS commands, and configuration parameters.</p>"},{"location":"api-reference/#core-eemt-functions","title":"Core EEMT Functions","text":""},{"location":"api-reference/#traditional-eemt-calculation","title":"Traditional EEMT Calculation","text":"<pre><code>def calculate_eemt_traditional(temperature, precipitation, elevation=None):\n    \"\"\"\n    Calculate EEMT using traditional climate-based approach\n\n    Parameters:\n    -----------\n    temperature : array_like\n        Monthly mean temperature [\u00b0C]\n    precipitation : array_like  \n        Monthly precipitation [mm]\n    elevation : array_like, optional\n        Elevation for lapse rate corrections [m]\n\n    Returns:\n    --------\n    eemt : array_like\n        Effective Energy and Mass Transfer [MJ m\u207b\u00b2 yr\u207b\u00b9]\n    e_bio : array_like\n        Biological energy component [MJ m\u207b\u00b2 yr\u207b\u00b9]\n    e_ppt : array_like\n        Precipitation energy component [MJ m\u207b\u00b2 yr\u207b\u00b9]\n\n    Notes:\n    ------\n    Based on Rasmussen et al. (2005, 2014) methodology.\n    Uses Lieth (1975) NPP equation and Hamon PET estimation.\n\n    Examples:\n    ---------\n    &gt;&gt;&gt; temp = np.array([5, 10, 15, 20, 18, 12, 8])  # Monthly temps\n    &gt;&gt;&gt; precip = np.array([50, 60, 80, 40, 30, 45, 55])  # Monthly precip\n    &gt;&gt;&gt; eemt, e_bio, e_ppt = calculate_eemt_traditional(temp, precip)\n    &gt;&gt;&gt; print(f\"Annual EEMT: {eemt:.1f} MJ/m\u00b2/yr\")\n    \"\"\"\n</code></pre>"},{"location":"api-reference/#topographic-eemt-calculation","title":"Topographic EEMT Calculation","text":"<pre><code>def calculate_eemt_topographic(dem_file, climate_data, solar_data, \n                             output_dir, mcwi_method='d_infinity'):\n    \"\"\"\n    Calculate EEMT with topographic controls on energy and water balance\n\n    Parameters:\n    -----------\n    dem_file : str or Path\n        Path to digital elevation model (GeoTIFF)\n    climate_data : dict\n        Dictionary containing climate arrays:\n        - 'temperature': Monthly temperature [\u00b0C] \n        - 'precipitation': Monthly precipitation [mm]\n        - 'humidity': Relative humidity [%]\n        - 'wind_speed': Wind speed [m/s]\n    solar_data : dict\n        Solar radiation data from r.sun calculations:\n        - 'global_radiation': Monthly solar [Wh/m\u00b2]\n        - 'diffuse_radiation': Diffuse component [Wh/m\u00b2]\n        - 'direct_radiation': Direct beam component [Wh/m\u00b2]\n    output_dir : str or Path\n        Output directory for intermediate files\n    mcwi_method : str, default 'd_infinity'\n        Flow routing method: 'd_infinity', 'mfd', 'sfd'\n\n    Returns:\n    --------\n    eemt_result : dict\n        Results dictionary containing:\n        - 'eemt': Total EEMT [MJ m\u207b\u00b2 yr\u207b\u00b9]\n        - 'e_bio': Biological component [MJ m\u207b\u00b2 yr\u207b\u00b9] \n        - 'e_ppt': Precipitation component [MJ m\u207b\u00b2 yr\u207b\u00b9]\n        - 'mcwi': Mass Conservative Wetness Index\n        - 'solar_ratio': Topographic solar modification factor\n\n    Notes:\n    ------\n    Implements Rasmussen et al. (2014) EEMT_TOPO methodology.\n    Requires GRASS GIS for terrain analysis and solar calculations.\n\n    Examples:\n    ---------\n    &gt;&gt;&gt; climate = load_daymet_data('study_area.shp', 2015, 2020)\n    &gt;&gt;&gt; solar = calculate_annual_solar('dem.tif', threads=8)\n    &gt;&gt;&gt; result = calculate_eemt_topographic('dem.tif', climate, solar, 'output/')\n    &gt;&gt;&gt; print(f\"Mean topographic EEMT: {np.mean(result['eemt']):.1f} MJ/m\u00b2/yr\")\n    \"\"\"\n</code></pre>"},{"location":"api-reference/#vegetation-eemt-calculation","title":"Vegetation EEMT Calculation","text":"<pre><code>def calculate_eemt_vegetation(dem_file, climate_data, vegetation_data,\n                           output_dir, lai_method='ndvi', resistance_model='kelliher'):\n    \"\"\"\n    Calculate EEMT with full vegetation and topographic integration\n\n    Parameters:\n    -----------\n    dem_file : str or Path\n        Digital elevation model file path\n    climate_data : dict\n        Complete climate dataset with:\n        - 'temperature': Temperature arrays [\u00b0C]\n        - 'precipitation': Precipitation arrays [mm] \n        - 'humidity': Relative humidity [%]\n        - 'wind_speed': Wind speed [m/s]\n        - 'net_radiation': Net radiation [W/m\u00b2]\n    vegetation_data : dict\n        Vegetation structure data:\n        - 'lai': Leaf Area Index [-] \n        - 'canopy_height': Canopy height [m]\n        - 'ndvi': Normalized Difference Vegetation Index [-]\n        - 'biomass': Aboveground biomass [Mg/ha] (optional)\n    output_dir : str or Path\n        Output directory\n    lai_method : str, default 'ndvi'\n        LAI calculation method: 'ndvi', 'modis', 'direct'\n    resistance_model : str, default 'kelliher' \n        Surface resistance model: 'kelliher', 'jarvis', 'stewart'\n\n    Returns:\n    --------\n    eemt_result : dict\n        Complete EEMT results:\n        - 'eemt': Total EEMT [MJ m\u207b\u00b2 yr\u207b\u00b9]\n        - 'e_bio': Biological energy [MJ m\u207b\u00b2 yr\u207b\u00b9]\n        - 'e_ppt': Precipitation energy [MJ m\u207b\u00b2 yr\u207b\u00b9] \n        - 'aet': Actual evapotranspiration [mm/yr]\n        - 'npp': Net primary production [kg/m\u00b2/yr]\n        - 'surface_resistance': Surface resistance [s/m]\n        - 'lai_effective': Effective LAI used in calculations\n\n    Notes:\n    ------\n    Implements Rasmussen et al. (2014) EEMT_TOPO-VEG methodology.\n    Uses Penman-Monteith equation with vegetation-specific parameters.\n    Accounts for canopy structure effects on energy and water balance.\n\n    Examples:\n    ---------\n    &gt;&gt;&gt; # Load vegetation data from satellite\n    &gt;&gt;&gt; vegetation = {\n    ...     'ndvi': load_landsat_ndvi('study_area.shp', 2020),\n    ...     'canopy_height': load_lidar_canopy('lidar_data.las')\n    ... }\n    &gt;&gt;&gt; result = calculate_eemt_vegetation('dem.tif', climate, vegetation, 'output/')\n    &gt;&gt;&gt; print(f\"Vegetation EEMT: {np.mean(result['eemt']):.1f} MJ/m\u00b2/yr\")\n    \"\"\"\n</code></pre>"},{"location":"api-reference/#grass-gis-command-reference","title":"GRASS GIS Command Reference","text":""},{"location":"api-reference/#solar-radiation-rsun-family","title":"Solar Radiation (r.sun family)","text":""},{"location":"api-reference/#rsunmp-multi-processor-version","title":"r.sun.mp (Multi-processor version)","text":"<pre><code>r.sun.mp elevation=dem aspect=aspect slope=slope \\\\\n         day=180 step=0.25 \\\\\n         linke_value=3.0 albedo_value=0.2 \\\\\n         threads=8 \\\\\n         glob_rad=global_radiation \\\\\n         insol_time=sunshine_hours \\\\\n         [beam_rad=beam_radiation] \\\\\n         [diff_rad=diffuse_radiation] \\\\\n         [refl_rad=reflected_radiation]\n</code></pre> <p>Parameters: - <code>elevation=name</code> - Input elevation raster - <code>aspect=name</code> - Aspect in degrees (0-360\u00b0) - <code>slope=name</code> - Slope in degrees (0-90\u00b0) - <code>day=integer</code> - Day of year (1-365) - <code>step=float</code> - Time step in hours (0.25-1.0) - <code>linke_value=float</code> - Linke atmospheric turbidity (1.0-8.0) - <code>albedo_value=float</code> - Ground albedo (0.0-1.0) - <code>threads=integer</code> - Number of OpenMP threads - <code>glob_rad=name</code> - Output global radiation [Wh/m\u00b2] - <code>insol_time=name</code> - Output sunshine duration [hours]</p>"},{"location":"api-reference/#rsun-single-processor-version","title":"r.sun (Single-processor version)","text":"<pre><code>r.sun elevation=dem \\\\\n      [aspect=aspect] [slope=slope] \\\\\n      [lat=latitude] [lon=longitude] \\\\\n      [day=day_of_year] [time=decimal_time] \\\\\n      [step=time_step] \\\\\n      [glob_rad=output] [beam_rad=output] \\\\\n      [diff_rad=output] [refl_rad=output] \\\\\n      [insol_time=output]\n</code></pre> <p>Advanced Options: - <code>horizon_basename=basename</code> - Horizon angle rasters - <code>horizon_step=angle</code> - Horizon calculation step [degrees] - <code>civil_time=hour</code> - Local solar time - <code>solar_constant=value</code> - Solar constant [W/m\u00b2] - <code>distance_step=value</code> - Sampling distance [m]</p>"},{"location":"api-reference/#terrain-analysis","title":"Terrain Analysis","text":""},{"location":"api-reference/#rslopeaspect","title":"r.slope.aspect","text":"<pre><code>r.slope.aspect elevation=dem \\\\\n               slope=slope_output \\\\\n               aspect=aspect_output \\\\\n               [format=degrees|percent] \\\\\n               [precision=FCELL|DCELL] \\\\\n               [zscale=factor] \\\\\n               [min_slope=degrees]\n</code></pre>"},{"location":"api-reference/#rterraflow-flow-accumulation","title":"r.terraflow (Flow accumulation)","text":"<pre><code>r.terraflow elevation=dem \\\\\n            filled=filled_dem \\\\\n            direction=flow_direction \\\\\n            swatershed=watersheds \\\\\n            accumulation=flow_accumulation \\\\\n            tci=topographic_convergence_index\n</code></pre>"},{"location":"api-reference/#rwatershed-alternative-flow-routing","title":"r.watershed (Alternative flow routing)","text":"<pre><code>r.watershed elevation=dem \\\\\n            accumulation=flow_accum \\\\\n            drainage=flow_direction \\\\\n            basin=watersheds \\\\\n            stream=stream_network \\\\\n            [threshold=threshold_value] \\\\\n            [-s] [-4] [-a]\n</code></pre>"},{"location":"api-reference/#data-importexport","title":"Data Import/Export","text":""},{"location":"api-reference/#ringdal-import-raster-data","title":"r.in.gdal (Import raster data)","text":"<pre><code>r.in.gdal input=input_file.tif \\\\\n          output=grass_raster \\\\\n          [band=band_number] \\\\\n          [memory=memory_mb] \\\\\n          [target=target_crs] \\\\\n          [-o] [-e] [-f]\n</code></pre>"},{"location":"api-reference/#routgdal-export-raster-data","title":"r.out.gdal (Export raster data)","text":"<pre><code>r.out.gdal input=grass_raster \\\\\n           output=output_file.tif \\\\\n           format=GTiff \\\\\n           [type=data_type] \\\\\n           [nodata=nodata_value] \\\\\n           createopt=\"COMPRESS=LZW,TILED=YES\"\n</code></pre>"},{"location":"api-reference/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"api-reference/#solar-radiation-parameters","title":"Solar Radiation Parameters","text":"Parameter Range Default Description <code>day</code> 1-365 - Day of year for calculation <code>step</code> 0.1-2.0 0.25 Time step interval [hours] <code>linke_value</code> 1.0-8.0 3.0 Atmospheric turbidity factor <code>albedo_value</code> 0.0-1.0 0.2 Surface albedo coefficient <code>lat</code> -90 to 90 auto Latitude [decimal degrees] <code>solar_constant</code> 1300-1400 1367 Solar constant [W/m\u00b2]"},{"location":"api-reference/#processing-parameters","title":"Processing Parameters","text":"Parameter Range Default Description <code>threads</code> 1-64 auto OpenMP thread count <code>memory</code> 256-8192 2048 Memory cache [MB] <code>precision</code> FCELL/DCELL FCELL Output precision <code>compress</code> LZW/DEFLATE LZW Output compression"},{"location":"api-reference/#climate-thresholds","title":"Climate Thresholds","text":"Parameter Value Units Description <code>T_ref</code> 273.15 K Reference temperature (freezing) <code>h_BIO</code> 22\u00d710\u2076 J/kg Specific biomass enthalpy <code>c_w</code> 4.18\u00d710\u00b3 J/kg/K Specific heat of water <code>EEMT_threshold</code> 70 MJ/m\u00b2/yr Carbon/water dominance transition"},{"location":"api-reference/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/#common-error-codes","title":"Common Error Codes","text":"Error Cause Solution <code>GRASS: Location not found</code> Invalid GRASS database Check <code>GISDBASE</code> path <code>GDAL: Cannot open file</code> Missing input data Verify file paths <code>r.sun: Memory allocation failed</code> Insufficient RAM Reduce region size or tile processing <code>r.sun: Invalid day parameter</code> Day outside 1-365 range Check day parameter <code>Projection mismatch</code> CRS inconsistency Reproject data to common CRS"},{"location":"api-reference/#error-recovery-strategies","title":"Error Recovery Strategies","text":"<pre><code>def robust_eemt_calculation(dem_file, climate_dir, output_dir, max_retries=3):\n    \"\"\"\n    EEMT calculation with error recovery\n\n    Implements automatic retry, fallback methods, and error logging\n    \"\"\"\n\n    import logging\n    from time import sleep\n\n    # Configure logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.FileHandler(f'{output_dir}/eemt_calculation.log'),\n            logging.StreamHandler()\n        ]\n    )\n\n    for attempt in range(max_retries):\n        try:\n            # Attempt EEMT calculation\n            result = calculate_eemt_complete(dem_file, climate_dir, output_dir)\n            logging.info(f\"EEMT calculation successful on attempt {attempt + 1}\")\n            return result\n\n        except MemoryError as e:\n            logging.warning(f\"Memory error on attempt {attempt + 1}: {e}\")\n            if attempt &lt; max_retries - 1:\n                # Try with reduced resolution\n                logging.info(\"Retrying with reduced spatial resolution...\")\n                dem_file = reduce_resolution(dem_file, factor=2)\n            else:\n                raise\n\n        except FileNotFoundError as e:\n            logging.error(f\"Missing input file: {e}\")\n            raise\n\n        except subprocess.CalledProcessError as e:\n            logging.warning(f\"GRASS command failed on attempt {attempt + 1}: {e}\")\n            if attempt &lt; max_retries - 1:\n                sleep(5)  # Wait before retry\n                logging.info(\"Retrying GRASS operation...\")\n            else:\n                raise\n\n        except Exception as e:\n            logging.error(f\"Unexpected error: {e}\")\n            if attempt &lt; max_retries - 1:\n                sleep(10)\n                logging.info(\"Retrying with fresh environment...\")\n            else:\n                raise\n\n    raise RuntimeError(f\"EEMT calculation failed after {max_retries} attempts\")\n</code></pre>"},{"location":"api-reference/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api-reference/#memory-management","title":"Memory Management","text":"<pre><code>def optimize_grass_memory(max_memory_gb=16):\n    \"\"\"\n    Optimize GRASS GIS memory settings for large datasets\n\n    Parameters:\n    -----------\n    max_memory_gb : int\n        Maximum memory to allocate [GB]\n    \"\"\"\n\n    import os\n\n    # Set GRASS memory environment\n    cache_size = max_memory_gb * 1024  # Convert to MB\n\n    os.environ.update({\n        'GRASS_CACHE_SIZE': str(cache_size),\n        'GRASS_RASTER_TMPDIR_MAPSET': '/tmp',\n        'GRASS_VECTOR_TMPDIR_MAPSET': '/tmp',\n        'GRASS_COMPRESS_NULLS': '1',\n        'GRASS_RENDER_IMMEDIATE': 'FALSE'\n    })\n\n    print(f\"\u2713 GRASS memory optimized for {max_memory_gb} GB\")\n\ndef calculate_optimal_tile_size(dem_file, available_memory_gb=8):\n    \"\"\"\n    Calculate optimal tile size for memory-constrained processing\n\n    Parameters:\n    -----------\n    dem_file : str\n        Path to DEM file\n    available_memory_gb : int  \n        Available system memory [GB]\n\n    Returns:\n    --------\n    tile_size : int\n        Optimal tile size in pixels\n    overlap : int\n        Recommended overlap in pixels\n    \"\"\"\n\n    import rasterio\n\n    with rasterio.open(dem_file) as src:\n        width, height = src.width, src.height\n        dtype_size = np.dtype(src.dtypes[0]).itemsize\n\n    # Estimate memory usage per pixel (including intermediate arrays)\n    memory_per_pixel = dtype_size * 20  # Factor for r.sun calculations\n\n    # Calculate tile size that fits in available memory\n    available_memory_bytes = available_memory_gb * 1024**3\n    max_pixels = available_memory_bytes // memory_per_pixel\n    tile_size = int(np.sqrt(max_pixels))\n\n    # Ensure reasonable tile size\n    tile_size = max(256, min(tile_size, 4096))\n    overlap = max(32, tile_size // 16)  # 6.25% overlap\n\n    return tile_size, overlap\n</code></pre>"},{"location":"api-reference/#parallel-processing-configuration","title":"Parallel Processing Configuration","text":"<pre><code>def configure_parallel_processing(max_workers=None, threads_per_worker=4):\n    \"\"\"\n    Configure optimal parallel processing parameters\n\n    Parameters:\n    -----------\n    max_workers : int, optional\n        Maximum number of worker processes (default: CPU count // 4)\n    threads_per_worker : int\n        OpenMP threads per worker process\n\n    Returns:\n    --------\n    config : dict\n        Optimized processing configuration\n    \"\"\"\n\n    import multiprocessing as mp\n    import psutil\n\n    # Detect system capabilities\n    cpu_count = mp.cpu_count()\n    memory_gb = psutil.virtual_memory().total // (1024**3)\n\n    # Calculate optimal configuration\n    if max_workers is None:\n        max_workers = max(1, cpu_count // threads_per_worker)\n\n    # Memory per worker (reserve 2 GB for system)\n    memory_per_worker = max(2, (memory_gb - 2) // max_workers)\n\n    config = {\n        'max_workers': max_workers,\n        'threads_per_worker': threads_per_worker,\n        'memory_per_worker_gb': memory_per_worker,\n        'total_threads': max_workers * threads_per_worker,\n        'memory_efficiency': memory_per_worker / (memory_gb / max_workers)\n    }\n\n    print(f\"Parallel Processing Configuration:\")\n    print(f\"  Workers: {config['max_workers']}\")\n    print(f\"  Threads per worker: {config['threads_per_worker']}\")\n    print(f\"  Total threads: {config['total_threads']}\")\n    print(f\"  Memory per worker: {config['memory_per_worker_gb']} GB\")\n\n    return config\n</code></pre>"},{"location":"api-reference/#validation-functions","title":"Validation Functions","text":""},{"location":"api-reference/#statistical-validation","title":"Statistical Validation","text":"<pre><code>def validate_eemt_results(eemt_results, validation_data, method='pearson'):\n    \"\"\"\n    Validate EEMT results against field measurements\n\n    Parameters:\n    -----------\n    eemt_results : dict\n        EEMT calculation results\n    validation_data : dict\n        Validation datasets:\n        - 'soil_depth': Measured soil depths [cm]\n        - 'biomass': Measured biomass [Mg/ha]\n        - 'npp': Measured NPP [kg/m\u00b2/yr] \n        - 'coordinates': Sample locations\n    method : str\n        Validation method: 'pearson', 'spearman', 'rmse'\n\n    Returns:\n    --------\n    validation_results : dict\n        Validation statistics and plots\n    \"\"\"\n\n    from scipy import stats\n    import matplotlib.pyplot as plt\n\n    validation_results = {}\n\n    # Extract EEMT values at validation points\n    for data_type, data in validation_data.items():\n        if data_type == 'coordinates':\n            continue\n\n        # Extract EEMT values at measurement locations\n        eemt_at_points = extract_values_at_points(\n            eemt_results['eemt'], \n            validation_data['coordinates']\n        )\n\n        # Calculate validation statistics\n        if method == 'pearson':\n            r, p = stats.pearsonr(eemt_at_points, data)\n            validation_results[data_type] = {\n                'correlation': r,\n                'p_value': p,\n                'r_squared': r**2\n            }\n        elif method == 'rmse':\n            rmse = np.sqrt(np.mean((eemt_at_points - data)**2))\n            mae = np.mean(np.abs(eemt_at_points - data))\n            validation_results[data_type] = {\n                'rmse': rmse,\n                'mae': mae,\n                'bias': np.mean(eemt_at_points - data)\n            }\n\n    return validation_results\n\ndef cross_validate_eemt_methods(dem_file, climate_data, validation_points):\n    \"\"\"\n    Cross-validation of different EEMT calculation methods\n\n    Compares Traditional, Topographic, and Vegetation approaches\n    against field validation data\n    \"\"\"\n\n    methods = ['traditional', 'topographic', 'vegetation']\n    results = {}\n\n    for method in methods:\n        print(f\"Cross-validating {method} EEMT...\")\n\n        # Calculate EEMT using specific method\n        if method == 'traditional':\n            eemt = calculate_eemt_traditional(climate_data)\n        elif method == 'topographic': \n            eemt = calculate_eemt_topographic(dem_file, climate_data)\n        else:\n            eemt = calculate_eemt_vegetation(dem_file, climate_data)\n\n        # Validate against field data\n        validation = validate_eemt_results(eemt, validation_points)\n        results[method] = validation\n\n    # Compare methods\n    print(\"\\\\nMethod Comparison:\")\n    print(\"-\" * 50)\n    for method, validation in results.items():\n        if 'soil_depth' in validation:\n            r2 = validation['soil_depth']['r_squared']\n            print(f\"{method.capitalize():12} | R\u00b2 = {r2:.3f}\")\n\n    return results\n</code></pre>"},{"location":"api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api-reference/#data-processing-utilities","title":"Data Processing Utilities","text":"<pre><code>def extract_values_at_points(raster_file, coordinates, method='bilinear'):\n    \"\"\"Extract raster values at point locations\"\"\"\n\n    import rasterio\n    from rasterio.sample import sample_gen\n\n    with rasterio.open(raster_file) as src:\n        values = list(sample_gen(src, coordinates, indexes=1))\n\n    return np.array([val[0] for val in values])\n\ndef calculate_zonal_statistics(raster_file, zones_file, statistics=['mean', 'std']):\n    \"\"\"Calculate statistics by zones (e.g., elevation bands, watersheds)\"\"\"\n\n    from rasterstats import zonal_stats\n    import geopandas as gpd\n\n    # Load zones\n    zones = gpd.read_file(zones_file)\n\n    # Calculate statistics\n    stats_result = zonal_stats(\n        zones, \n        raster_file, \n        stats=statistics,\n        geojson_out=True\n    )\n\n    return gpd.GeoDataFrame.from_features(stats_result)\n\ndef resample_to_common_grid(file_list, reference_file, output_dir, method='bilinear'):\n    \"\"\"Resample all rasters to common grid\"\"\"\n\n    import subprocess\n    from pathlib import Path\n\n    output_dir = Path(output_dir)\n    output_dir.mkdir(exist_ok=True)\n\n    # Get reference grid parameters\n    with rasterio.open(reference_file) as src:\n        ref_transform = src.transform\n        ref_crs = src.crs\n        ref_width = src.width\n        ref_height = src.height\n\n    resampled_files = []\n\n    for input_file in file_list:\n\n        output_file = output_dir / f\"resampled_{Path(input_file).name}\"\n\n        # Use gdalwarp for resampling\n        cmd = [\n            'gdalwarp',\n            '-tr', str(ref_transform[0]), str(-ref_transform[4]),  # Resolution\n            '-te', str(ref_transform[2]), str(ref_transform[5]),   # Extent  \n                   str(ref_transform[2] + ref_width * ref_transform[0]),\n                   str(ref_transform[5] + ref_height * ref_transform[4]),\n            '-t_srs', str(ref_crs),  # Target CRS\n            '-r', method,            # Resampling method\n            '-co', 'COMPRESS=LZW',   # Compression\n            str(input_file),\n            str(output_file)\n        ]\n\n        subprocess.run(cmd, check=True)\n        resampled_files.append(str(output_file))\n\n    return resampled_files\n</code></pre>"},{"location":"api-reference/#command-line-interface","title":"Command Line Interface","text":""},{"location":"api-reference/#main-eemt-calculator-script","title":"Main EEMT Calculator Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nCommand line interface for EEMT calculations\nUsage: python eemt_calculator.py [options] dem_file\n\"\"\"\n\nusage_examples = '''\nExamples:\n  # Basic EEMT calculation\n  python eemt_calculator.py dem.tif --climate climate_data/ --output results/\n\n  # Topographic EEMT with parallel processing\n  python eemt_calculator.py dem.tif --method topographic --threads 16 \\\\\n    --climate daymet_data/ --output topo_results/\n\n  # Full vegetation EEMT with validation\n  python eemt_calculator.py dem.tif --method vegetation \\\\\n    --climate climate/ --vegetation ndvi.tif,lidar.las \\\\\n    --validate soil_samples.shp --output veg_results/\n\n  # Time series analysis\n  python eemt_calculator.py dem.tif --method topographic \\\\\n    --start-year 2000 --end-year 2020 --time-series \\\\\n    --output timeseries_results/\n'''\n\n# Command line argument definitions\nCLI_ARGUMENTS = {\n    'dem_file': {\n        'type': str,\n        'help': 'Input digital elevation model (GeoTIFF format)'\n    },\n    '--method': {\n        'choices': ['traditional', 'topographic', 'vegetation', 'all'],\n        'default': 'topographic',\n        'help': 'EEMT calculation method'\n    },\n    '--climate': {\n        'type': str, \n        'required': True,\n        'help': 'Climate data directory (DAYMET NetCDF files)'\n    },\n    '--output': {\n        'type': str,\n        'required': True, \n        'help': 'Output directory for results'\n    },\n    '--threads': {\n        'type': int,\n        'default': 4,\n        'help': 'Number of parallel processing threads'\n    },\n    '--step': {\n        'type': float,\n        'default': 0.25,\n        'help': 'Solar calculation time step [hours]'\n    },\n    '--linke': {\n        'type': float,\n        'default': 3.0,\n        'help': 'Linke atmospheric turbidity factor [1.0-8.0]'\n    },\n    '--albedo': {\n        'type': float, \n        'default': 0.2,\n        'help': 'Surface albedo coefficient [0.0-1.0]'\n    },\n    '--vegetation': {\n        'type': str,\n        'help': 'Vegetation data files (comma-separated): ndvi.tif,lidar.las'\n    },\n    '--start-year': {\n        'type': int,\n        'default': 2015,\n        'help': 'Start year for time series analysis'\n    },\n    '--end-year': {\n        'type': int, \n        'default': 2020,\n        'help': 'End year for time series analysis'\n    },\n    '--validate': {\n        'type': str,\n        'help': 'Validation data file (point shapefile with measurements)'\n    },\n    '--time-series': {\n        'action': 'store_true',\n        'help': 'Generate annual time series output'\n    },\n    '--tile-size': {\n        'type': int,\n        'default': 2048,\n        'help': 'Tile size for large dataset processing [pixels]'\n    },\n    '--verbose': {\n        'action': 'store_true',\n        'help': 'Enable verbose output'\n    }\n}\n</code></pre>"},{"location":"api-reference/#testing-framework","title":"Testing Framework","text":""},{"location":"api-reference/#unit-tests","title":"Unit Tests","text":"<pre><code>import unittest\nimport numpy as np\nfrom pathlib import Path\n\nclass TestEEMTCalculations(unittest.TestCase):\n    \"\"\"Unit tests for EEMT calculation functions\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test data\"\"\"\n        self.test_data_dir = Path('test_data')\n        self.test_data_dir.mkdir(exist_ok=True)\n\n        # Create synthetic test DEM\n        self.create_test_dem()\n\n        # Create synthetic climate data\n        self.create_test_climate()\n\n    def test_traditional_eemt(self):\n        \"\"\"Test traditional EEMT calculation\"\"\"\n\n        # Simple test case\n        temp = np.array([15.0])  # \u00b0C\n        precip = np.array([50.0])  # mm/month\n\n        eemt, e_bio, e_ppt = calculate_eemt_traditional(temp, precip)\n\n        # Check output ranges\n        self.assertGreater(eemt[0], 0, \"EEMT should be positive\")\n        self.assertLess(eemt[0], 100, \"EEMT should be reasonable (&lt;100 MJ/m\u00b2/yr)\")\n\n        # Check components\n        self.assertGreater(e_bio[0], 0, \"E_BIO should be positive\")\n        self.assertGreaterEqual(e_ppt[0], 0, \"E_PPT should be non-negative\")\n\n    def test_solar_radiation_range(self):\n        \"\"\"Test solar radiation calculations produce reasonable values\"\"\"\n\n        # Test with synthetic DEM\n        dem_file = self.test_data_dir / 'test_dem.tif'\n\n        # Should complete without errors\n        try:\n            solar_result = calculate_annual_solar(dem_file, days=[180])  # Summer solstice\n            self.assertTrue(True, \"Solar calculation completed\")\n        except Exception as e:\n            self.fail(f\"Solar calculation failed: {e}\")\n\n    def test_aspect_effects(self):\n        \"\"\"Test that north-facing slopes have higher EEMT\"\"\"\n\n        # Create test data with known aspect effects\n        north_slope_eemt = calculate_eemt_topographic(\n            self.create_test_slope(aspect=0)  # North-facing\n        )\n\n        south_slope_eemt = calculate_eemt_topographic(\n            self.create_test_slope(aspect=180)  # South-facing\n        )\n\n        # North slopes should have higher EEMT in water-limited environments\n        self.assertGreater(\n            np.mean(north_slope_eemt),\n            np.mean(south_slope_eemt),\n            \"North-facing slopes should have higher EEMT\"\n        )\n\n    def create_test_dem(self):\n        \"\"\"Create synthetic DEM for testing\"\"\"\n\n        # Create elevation gradient\n        x, y = np.meshgrid(np.linspace(0, 1000, 100), np.linspace(0, 1000, 100))\n        elevation = 1000 + x * 0.5 + y * 0.3 + np.random.normal(0, 10, (100, 100))\n\n        # Save as GeoTIFF\n        profile = {\n            'driver': 'GTiff',\n            'height': 100,\n            'width': 100,\n            'count': 1,\n            'dtype': 'float32',\n            'crs': 'EPSG:4326',\n            'transform': rasterio.transform.from_bounds(-111, 32, -110, 33, 100, 100)\n        }\n\n        with rasterio.open(self.test_data_dir / 'test_dem.tif', 'w', **profile) as dst:\n            dst.write(elevation.astype(np.float32), 1)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre>"},{"location":"api-reference/#integration-tests","title":"Integration Tests","text":"<pre><code>#!/bin/bash\n# Integration test suite for EEMT workflows\n\nset -e\n\necho \"=== EEMT Integration Tests ===\"\n\n# Test 1: Basic workflow with sample data\necho \"Test 1: Basic EEMT workflow...\"\npython eemt_calculator.py test_data/sample_dem.tif \\\\\n  --climate test_data/climate/ \\\\\n  --output test_results/basic/ \\\\\n  --method traditional\n\n# Test 2: Parallel processing\necho \"Test 2: Parallel solar calculation...\"\npython eemt_calculator.py test_data/sample_dem.tif \\\\\n  --climate test_data/climate/ \\\\\n  --output test_results/parallel/ \\\\\n  --method topographic \\\\\n  --threads 4\n\n# Test 3: Large dataset handling\necho \"Test 3: Large dataset processing...\"\npython eemt_calculator.py test_data/large_dem.tif \\\\\n  --climate test_data/climate/ \\\\\n  --output test_results/large/ \\\\\n  --tile-size 1024\n\n# Test 4: Validation\necho \"Test 4: Results validation...\"\npython validate_results.py test_results/ test_data/validation/\n\necho \"\u2713 All integration tests passed\"\n</code></pre> <p>This API reference provides the complete technical foundation for implementing and extending EEMT calculations with modern computational approaches and comprehensive error handling.</p>"},{"location":"background/","title":"Scientific Background","text":""},{"location":"background/#what-is-the-critical-zone","title":"What is the Critical Zone?","text":"<p>The Critical Zone is Earth's near-surface environment extending from the top of the vegetation canopy down to the groundwater. This zone supports all terrestrial life and controls:</p> <ul> <li>Fresh water availability and quality</li> <li>Soil formation and agricultural productivity  </li> <li>Carbon storage and climate regulation</li> <li>Biodiversity and ecosystem services</li> <li>Natural hazard mitigation</li> </ul> <p> </p> The Critical Zone extends from the vegetation canopy to groundwater, encompassing the zone where rock, soil, water, air, and living organisms interact."},{"location":"background/#energy-and-mass-transfer-principles","title":"Energy and Mass Transfer Principles","text":""},{"location":"background/#thermodynamic-foundation","title":"Thermodynamic Foundation","text":"<p>The Critical Zone operates as an open thermodynamic system where:</p> <ul> <li>Energy and mass flow down gradients (solar, chemical, gravitational)</li> <li>Internal structures develop to optimize energy dissipation</li> <li>System organization emerges from energy flux patterns</li> <li>Steady-state conditions balance inputs and outputs</li> </ul> \\[\\frac{d\\mathcal{U}_{CZ}}{dt} = \\mathcal{K} - T\\sigma\\] <p>Where: - \ud835\udcb0<sub>CZ</sub> = Critical Zone energy storage [J m\u207b\u00b2] - \ud835\udca6 = Energy flux through the system [W m\u207b\u00b2] - T = System temperature [K] - \u03c3 = Entropy production rate [W m\u207b\u00b2 K\u207b\u00b9]</p>"},{"location":"background/#energy-balance-components","title":"Energy Balance Components","text":"<p>The total energy flux includes multiple components:</p> \\[E_{Total} = E_{ET} + E_{PPT} + E_{BIO} + E_{ELEV} + E_{GEO} + \\sum E_i\\] Component Description Magnitude Role E<sub>ET</sub> Evapotranspiration ~10\u2075 MJ m\u207b\u00b2 yr\u207b\u00b9 Returns to atmosphere E<sub>PPT</sub> Precipitation energy ~10\u00b2 MJ m\u207b\u00b2 yr\u207b\u00b9 Subsurface heat transfer E<sub>BIO</sub> Primary production ~10\u00b9 MJ m\u207b\u00b2 yr\u207b\u00b9 Biological energy storage E<sub>ELEV</sub> Gravitational potential ~10\u2070 MJ m\u207b\u00b2 yr\u207b\u00b9 Physical denudation E<sub>GEO</sub> Chemical potential ~10\u207b\u00b9 MJ m\u207b\u00b2 yr\u207b\u00b9 Chemical weathering"},{"location":"background/#eemt-focus","title":"EEMT Focus","text":"<p>Effective Energy and Mass Transfer focuses on subsurface energy flux:</p> \\[\\text{EEMT} = E_{BIO} + E_{PPT}\\] <p>This represents the energy effectively transferred to drive: - Soil formation processes - Chemical weathering reactions - Biological productivity - Carbon sequestration - Nutrient cycling</p>"},{"location":"background/#physical-processes","title":"Physical Processes","text":""},{"location":"background/#solar-radiation-and-topography","title":"Solar Radiation and Topography","text":"<p>Solar radiation provides the primary energy input to the Critical Zone. Topographic effects modify radiation through:</p>"},{"location":"background/#slope-and-aspect-effects","title":"Slope and Aspect Effects","text":"<ul> <li>North-facing slopes: Reduced direct radiation, higher soil moisture</li> <li>South-facing slopes: Maximum radiation, increased evapotranspiration  </li> <li>Slope angle: Controls radiation intensity and duration</li> </ul>"},{"location":"background/#shading-and-obstruction","title":"Shading and Obstruction","text":"<ul> <li>Horizon effects: Adjacent terrain blocks incoming radiation</li> <li>Vegetation shading: Canopy intercepts and redistributes energy</li> <li>Seasonal variation: Sun angle changes modify topographic effects</li> </ul>"},{"location":"background/#water-and-energy-coupling","title":"Water and Energy Coupling","text":"<p>Water acts as both a mass flux and energy carrier:</p>"},{"location":"background/#precipitation-energy-eppt","title":"Precipitation Energy (E<sub>PPT</sub>)","text":"<pre><code>E_PPT = F \u00d7 c_w \u00d7 \u0394T [W m\u207b\u00b2]\n</code></pre> <p>Where: - F = Effective precipitation flux [kg m\u207b\u00b2 s\u207b\u00b9] - c<sub>w</sub> = Specific heat of water (4,180 J kg\u207b\u00b9 K\u207b\u00b9) - \u0394T = Temperature above freezing [K]</p>"},{"location":"background/#water-redistribution","title":"Water Redistribution","text":"<ul> <li>Infiltration vs. runoff: Controls subsurface energy delivery</li> <li>Topographic convergence: Concentrates water and energy flux</li> <li>Evapotranspiration: Returns energy to atmosphere</li> </ul>"},{"location":"background/#biological-energy-ebio","title":"Biological Energy (E<sub>BIO</sub>)","text":"<p>Primary production stores solar energy in chemical bonds:</p>"},{"location":"background/#photosynthesis-energy-storage","title":"Photosynthesis Energy Storage","text":"<pre><code>E_BIO = NPP \u00d7 h_BIO [W m\u207b\u00b2]\n</code></pre> <p>Where: - NPP = Net Primary Production [kg m\u207b\u00b2 s\u207b\u00b9] - h<sub>BIO</sub> = Specific biomass enthalpy (22 \u00d7 10\u2076 J kg\u207b\u00b9)</p>"},{"location":"background/#carbon-energy-coupling","title":"Carbon-Energy Coupling","text":"<ul> <li>CO\u2082 fixation: Solar energy \u2192 chemical energy</li> <li>Decomposition: Chemical energy \u2192 heat + nutrients</li> <li>Root activity: Drives chemical weathering reactions</li> </ul>"},{"location":"background/#critical-zone-structure-and-function","title":"Critical Zone Structure and Function","text":""},{"location":"background/#emergent-organization","title":"Emergent Organization","text":"<p>EEMT drives the formation of organized Critical Zone structures:</p>"},{"location":"background/#soil-horizons","title":"Soil Horizons","text":"<ul> <li>O horizon: Organic matter accumulation</li> <li>A horizon: Mineral-organic mixing</li> <li>B horizon: Clay and nutrient accumulation</li> <li>C horizon: Weathered parent material</li> </ul>"},{"location":"background/#vegetation-patterns","title":"Vegetation Patterns","text":"<ul> <li>Productivity gradients: Follow EEMT patterns</li> <li>Species composition: Adapted to local energy/water balance</li> <li>Biomass allocation: Optimizes energy capture and water access</li> </ul>"},{"location":"background/#landscape-features","title":"Landscape Features","text":"<ul> <li>Channel networks: Organize water and sediment transport</li> <li>Slope profiles: Balance weathering and erosion rates</li> <li>Aspect patterns: Reflect energy-controlled processes</li> </ul>"},{"location":"background/#threshold-behavior","title":"Threshold Behavior","text":"<p>EEMT exhibits critical thresholds that control system behavior:</p>"},{"location":"background/#water-vs-energy-limitation","title":"Water vs. Energy Limitation","text":"<p>Threshold: ~70 MJ m\u207b\u00b2 yr\u207b\u00b9</p> <ul> <li>Below threshold: Water-limited, E<sub>BIO</sub> dominates</li> <li>Above threshold: Energy-limited, E<sub>PPT</sub> dominates</li> </ul>"},{"location":"background/#system-transitions","title":"System Transitions","text":"<ul> <li>Vegetation shifts: Grassland \u2194 forest transitions</li> <li>Soil development: Entisol \u2194 Mollisol \u2194 Alfisol progression</li> <li>Geomorphic regime: Weathering-limited \u2194 transport-limited</li> </ul>"},{"location":"background/#spatial-and-temporal-scales","title":"Spatial and Temporal Scales","text":""},{"location":"background/#spatial-scale-integration","title":"Spatial Scale Integration","text":"<p>EEMT operates across multiple spatial scales:</p>"},{"location":"background/#local-scale-1-100-m","title":"Local Scale (1-100 m)","text":"<ul> <li>Process-level understanding: Individual tree, soil pedon</li> <li>High-resolution data: LiDAR, field measurements</li> <li>Detailed process modeling: Hourly energy/water balance</li> </ul>"},{"location":"background/#landscape-scale-100-m-10-km","title":"Landscape Scale (100 m - 10 km)","text":"<ul> <li>Pattern-process relationships: Topographic controls</li> <li>Moderate-resolution data: Landsat, weather stations</li> <li>Statistical modeling: Spatial correlation analysis</li> </ul>"},{"location":"background/#regional-scale-10-1000-km","title":"Regional Scale (10-1000 km)","text":"<ul> <li>Climate gradient analysis: Elevation, latitude effects</li> <li>Coarse-resolution data: MODIS, climate models</li> <li>Empirical relationships: Broad pattern identification</li> </ul>"},{"location":"background/#temporal-scale-integration","title":"Temporal Scale Integration","text":""},{"location":"background/#short-term-processes-days-to-years","title":"Short-term Processes (days to years)","text":"<ul> <li>Weather variability: Daily climate fluctuations</li> <li>Seasonal cycles: Vegetation phenology, soil temperature</li> <li>Extreme events: Drought, fire, flooding impacts</li> </ul>"},{"location":"background/#medium-term-dynamics-years-to-centuries","title":"Medium-term Dynamics (years to centuries)","text":"<ul> <li>Climate oscillations: El Ni\u00f1o, Pacific Decadal Oscillation</li> <li>Vegetation succession: Post-disturbance recovery</li> <li>Soil profile development: Horizon differentiation</li> </ul>"},{"location":"background/#long-term-evolution-centuries-to-millennia","title":"Long-term Evolution (centuries to millennia)","text":"<ul> <li>Climate change: Holocene environmental shifts</li> <li>Landscape evolution: Erosion, weathering, soil formation</li> <li>Ecosystem migration: Species range shifts</li> </ul>"},{"location":"background/#mathematical-framework","title":"Mathematical Framework","text":""},{"location":"background/#open-system-thermodynamics","title":"Open System Thermodynamics","text":"<p>The Critical Zone energy balance follows fundamental thermodynamic principles:</p>"},{"location":"background/#first-law-energy-conservation","title":"First Law (Energy Conservation)","text":"\\[\\frac{dU}{dt} = Q - W\\] <p>Where U = internal energy, Q = heat input, W = work done by system</p>"},{"location":"background/#second-law-entropy-increase","title":"Second Law (Entropy Increase)","text":"\\[\\frac{dS}{dt} = \\frac{Q}{T} + \\sigma\\] <p>Where S = entropy, \u03c3 = irreversible entropy production</p>"},{"location":"background/#exergy-concept","title":"Exergy Concept","text":"\\[\\text{Exergy} = \\text{Energy} - T_0 \\times \\text{Entropy}\\] <p>Exergy represents the maximum useful work extractable from the system.</p>"},{"location":"background/#statistical-relationships","title":"Statistical Relationships","text":"<p>EEMT exhibits predictable relationships with Critical Zone properties:</p>"},{"location":"background/#power-law-scaling","title":"Power Law Scaling","text":"<p><pre><code>Biomass = \u03b1 \u00d7 EEMT^\u03b2\n</code></pre> Where \u03b1 = 0.032 kg m\u00b2 yr ha\u207b\u00b9 MJ\u207b\u00b9, \u03b2 = 3.22</p>"},{"location":"background/#exponential-relationships","title":"Exponential Relationships","text":"<p><pre><code>Soil_Depth = \u03b3 \u00d7 exp(\u03b4 \u00d7 EEMT)\n</code></pre> For specific lithologies and climate conditions</p>"},{"location":"background/#threshold-functions","title":"Threshold Functions","text":"<pre><code>f(EEMT) = {\n  f\u2081(EEMT)  if EEMT &lt; 70 MJ/m\u00b2/yr\n  f\u2082(EEMT)  if EEMT \u2265 70 MJ/m\u00b2/yr\n}\n</code></pre>"},{"location":"background/#model-validation","title":"Model Validation","text":""},{"location":"background/#field-validation-studies","title":"Field Validation Studies","text":"<p>EEMT has been validated against multiple field datasets:</p>"},{"location":"background/#soil-properties","title":"Soil Properties","text":"<ul> <li>Soil depth: r\u00b2 = 0.77 for topographic EEMT</li> <li>Clay content: Significant correlation across climate gradients</li> <li>Organic matter: Strong relationship in temperate systems</li> <li>Chemical weathering: Linear correlation in humid environments</li> </ul>"},{"location":"background/#vegetation-properties","title":"Vegetation Properties","text":"<ul> <li>Aboveground biomass: Power law relationship (r\u00b2 = 0.98)</li> <li>Leaf area index: Moderate correlation in forest systems</li> <li>Net primary production: Good agreement with flux tower data</li> <li>Species composition: Predictive of functional groups</li> </ul>"},{"location":"background/#geomorphic-properties","title":"Geomorphic Properties","text":"<ul> <li>Erosion rates: Inverse relationship in high-EEMT systems</li> <li>Chemical denudation: Linear increase with EEMT</li> <li>Regolith thickness: Exponential relationship</li> <li>Landscape relief: Controls on maximum EEMT values</li> </ul> <p>This framework provides the scientific foundation for understanding how energy drives Critical Zone processes and enables quantitative prediction of landscape evolution and ecosystem function.</p>"},{"location":"data-sources/","title":"Data Sources for EEMT Calculations","text":""},{"location":"data-sources/#overview","title":"Overview","text":"<p>EEMT calculations require high-quality elevation and climate data. This guide covers accessing publicly available datasets optimized for Critical Zone analysis.</p>"},{"location":"data-sources/#quick-reference","title":"Quick Reference","text":"Data Type Source Resolution Coverage API Access Elevation USGS 3DEP 1m, 10m, 30m United States \u2705 OpenTopography Variable Global \u2705 FABDEM 30m Global \u274c Climate DAYMET 1km daily North America \u2705 PRISM 800m monthly United States \u2705 GridMET 4km daily United States \u2705 Satellite Landsat 30m Global \u2705 MODIS 250m-1km Global \u2705"},{"location":"data-sources/#elevation-data","title":"Elevation Data","text":""},{"location":"data-sources/#usgs-3dep-3d-elevation-program","title":"USGS 3DEP (3D Elevation Program)","text":"<p>Best for: High-resolution analysis in the United States</p>"},{"location":"data-sources/#access-methods","title":"Access Methods","text":"<p>1. National Map Downloader <pre><code># Direct download interface\nhttps://apps.nationalmap.gov/downloader/\n\n# Select area of interest, choose elevation products:\n# - 1m DEM (lidar-derived, best quality)\n# - 1/3 arc-second (~10m, good coverage) \n# - 1 arc-second (~30m, complete coverage)\n</code></pre></p> <p>2. USGS API Access <pre><code>import requests\nimport geopandas as gpd\n\ndef download_3dep(bbox, resolution='10m'):\n    \"\"\"\n    Download USGS 3DEP elevation data\n\n    Parameters:\n    bbox: [west, south, east, north] in decimal degrees\n    resolution: '1m', '10m', or '30m'\n    \"\"\"\n\n    base_url = \"https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/\"\n\n    if resolution == '1m':\n        dataset = \"USGS_LPC\"\n    elif resolution == '10m':  \n        dataset = \"USGS_NED_13\"\n    else:\n        dataset = \"USGS_NED_1\"\n\n    # Construct download URL\n    url = f\"{base_url}{dataset}?west={bbox[0]}&amp;south={bbox[1]}&amp;east={bbox[2]}&amp;north={bbox[3]}&amp;outputFormat=GTiff\"\n\n    return url\n\n# Example usage\narizona_bbox = [-111.5, 32.0, -110.5, 32.5]  \ndem_url = download_3dep(arizona_bbox, '10m')\n</code></pre></p> <p>3. Cloud-Optimized Access <pre><code>import rasterio\nfrom rasterio.session import AWSSession\n\n# Access 3DEP COGs on AWS Open Data\naws_session = AWSSession(profile_name='default')\nwith rasterio.Env(session=aws_session):\n    with rasterio.open('s3://prd-tnm/StagedProducts/Elevation/1m/Projects/...') as src:\n        dem_data = src.read(1)\n</code></pre></p>"},{"location":"data-sources/#opentopography","title":"OpenTopography","text":"<p>Best for: Global coverage, lidar access, research applications</p>"},{"location":"data-sources/#web-interface","title":"Web Interface","text":"<pre><code># OpenTopography Portal\nhttps://portal.opentopography.org/\n\n# Select dataset:\n# - SRTM GL1 (30m global)\n# - SRTM GL3 (90m global)  \n# - ALOS World 3D (30m global)\n# - Regional lidar datasets\n</code></pre>"},{"location":"data-sources/#api-access","title":"API Access","text":"<pre><code>import requests\n\ndef download_opentopo(bbox, dem_type='SRTMGL1'):\n    \"\"\"\n    Download DEM from OpenTopography API\n\n    Parameters:\n    bbox: [west, south, east, north] in decimal degrees\n    dem_type: 'SRTMGL1', 'SRTMGL3', 'ALOS', 'COP30', 'COP90'\n    \"\"\"\n\n    base_url = \"https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/\"\n\n    params = {\n        'demtype': dem_type,\n        'west': bbox[0],\n        'south': bbox[1], \n        'east': bbox[2],\n        'north': bbox[3],\n        'outputFormat': 'GTiff'\n    }\n\n    response = requests.get(f\"{base_url}/API/globaldem\", params=params)\n\n    if response.status_code == 200:\n        with open(f'{dem_type}_dem.tif', 'wb') as f:\n            f.write(response.content)\n        return f'{dem_type}_dem.tif'\n    else:\n        raise Exception(f\"Download failed: {response.status_code}\")\n\n# Example usage\nbbox = [-111.5, 32.0, -110.5, 32.5]\ndem_file = download_opentopo(bbox, 'SRTMGL1')\n</code></pre>"},{"location":"data-sources/#lidar-point-cloud-access","title":"Lidar Point Cloud Access","text":"<pre><code>import pdal\nimport json\n\n# Download lidar point cloud data\npipeline = {\n    \"pipeline\": [\n        {\n            \"type\": \"readers.ept\",\n            \"filename\": \"https://cloud.sdsc.edu/v1/AUTH_opentopography/PC/CA_FullState_2019/ept.json\",\n            \"bounds\": \"([-111.5, -111.0], [32.0, 32.5])\"\n        },\n        {\n            \"type\": \"writers.las\",\n            \"filename\": \"output.las\"\n        }\n    ]\n}\n\npdal_pipeline = pdal.Pipeline(json.dumps(pipeline))\npdal_pipeline.execute()\n</code></pre>"},{"location":"data-sources/#global-dems","title":"Global DEMs","text":""},{"location":"data-sources/#fabdem-forest-and-buildings-removed-dem","title":"FABDEM (Forest And Buildings removed DEM)","text":"<pre><code># Access via Google Earth Engine\nimport ee\n\nee.Initialize()\n\n# Load FABDEM\nfabdem = ee.Image(\"projects/sat-io/open-datasets/FABDEM\")\n\n# Export specific region\ntask = ee.batch.Export.image.toDrive(\n    image=fabdem.select('elevation'),\n    description='FABDEM_export',\n    folder='EarthEngine',\n    scale=30,\n    region=ee.Geometry.Rectangle([-111.5, 32.0, -110.5, 32.5]),\n    crs='EPSG:4326'\n)\ntask.start()\n</code></pre>"},{"location":"data-sources/#copernicus-dem","title":"Copernicus DEM","text":"<pre><code># Download via Copernicus Data Space\n# https://dataspace.copernicus.eu/\n\n# Available resolutions:\n# - COP-DEM 30m (global)\n# - COP-DEM 90m (global)\n\n# API access requires registration\n</code></pre>"},{"location":"data-sources/#climate-data","title":"Climate Data","text":""},{"location":"data-sources/#daymet-daily-surface-weather-data","title":"DAYMET (Daily Surface Weather Data)","text":"<p>Best for: High-resolution daily meteorology across North America</p>"},{"location":"data-sources/#variables-available","title":"Variables Available","text":"<ul> <li>tmin: Daily minimum temperature (\u00b0C)</li> <li>tmax: Daily maximum temperature (\u00b0C)  </li> <li>prcp: Daily precipitation (mm/day)</li> <li>srad: Shortwave radiation (W/m\u00b2)</li> <li>vp: Water vapor pressure (Pa)</li> <li>swe: Snow water equivalent (kg/m\u00b2)</li> <li>dayl: Day length (s/day)</li> </ul>"},{"location":"data-sources/#api-access_1","title":"API Access","text":"<pre><code>import requests\nimport xarray as xr\nfrom datetime import datetime\n\ndef download_daymet(lat, lon, start_year, end_year, variables=['tmin', 'tmax', 'prcp']):\n    \"\"\"\n    Download DAYMET data for point location\n\n    Parameters:\n    lat, lon: coordinates in decimal degrees\n    start_year, end_year: year range\n    variables: list of variable names\n    \"\"\"\n\n    base_url = \"https://daymet.ornl.gov/single-pixel/api/data\"\n\n    params = {\n        'lat': lat,\n        'lon': lon,\n        'vars': ','.join(variables),\n        'start': start_year,\n        'end': end_year,\n        'format': 'json'\n    }\n\n    response = requests.get(base_url, params=params)\n    data = response.json()\n\n    return data\n\n# Example usage\ntucson_data = download_daymet(32.25, -110.97, 2015, 2020, \n                            ['tmin', 'tmax', 'prcp', 'vp'])\n</code></pre>"},{"location":"data-sources/#spatial-data-access","title":"Spatial Data Access","text":"<pre><code>def download_daymet_spatial(bbox, year, variable='tmin'):\n    \"\"\"\n    Download DAYMET spatial data via THREDDS\n\n    Parameters:\n    bbox: [west, south, east, north]\n    year: data year\n    variable: 'tmin', 'tmax', 'prcp', 'srad', 'vp', 'swe', 'dayl'\n    \"\"\"\n\n    base_url = \"https://thredds.daac.ornl.gov/thredds/dodsC/ornldaac/1328\"\n    nc_url = f\"{base_url}/daymet_v4_daily_na_{variable}_{year}.nc\"\n\n    # Open with xarray\n    ds = xr.open_dataset(nc_url)\n\n    # Subset to bounding box\n    subset = ds.sel(\n        x=slice(bbox[0], bbox[2]),\n        y=slice(bbox[1], bbox[3])\n    )\n\n    return subset\n\n# Example usage\nbbox = [-111.5, 32.0, -110.5, 32.5]\ntemp_data = download_daymet_spatial(bbox, 2020, 'tmin')\n</code></pre>"},{"location":"data-sources/#bulk-download-script","title":"Bulk Download Script","text":"<pre><code>import os\nfrom concurrent.futures import ThreadPoolExecutor\nimport subprocess\n\ndef download_daymet_bulk(bbox, years, variables, output_dir):\n    \"\"\"\n    Bulk download DAYMET data using wget\n    \"\"\"\n\n    os.makedirs(output_dir, exist_ok=True)\n\n    def download_file(url, filename):\n        cmd = f\"wget -O {output_dir}/{filename} '{url}'\"\n        subprocess.run(cmd, shell=True)\n\n    download_tasks = []\n\n    for year in years:\n        for var in variables:\n            url = f\"https://thredds.daac.ornl.gov/thredds/fileServer/ornldaac/1328/daymet_v4_daily_na_{var}_{year}.nc\"\n            filename = f\"daymet_{var}_{year}.nc\"\n            download_tasks.append((url, filename))\n\n    # Parallel downloads\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        for url, filename in download_tasks:\n            executor.submit(download_file, url, filename)\n\n# Example usage  \nyears = range(2015, 2021)\nvariables = ['tmin', 'tmax', 'prcp', 'vp']\ndownload_daymet_bulk(bbox, years, variables, 'daymet_data')\n</code></pre>"},{"location":"data-sources/#prism-parameter-elevation-regressions-on-independent-slopes-model","title":"PRISM (Parameter-elevation Regressions on Independent Slopes Model)","text":"<p>Best for: High-resolution monthly climate normals for the United States</p>"},{"location":"data-sources/#access-methods_1","title":"Access Methods","text":"<pre><code>import requests\nfrom bs4 import BeautifulSoup\n\ndef download_prism(bbox, year, variable='ppt', temporal='monthly'):\n    \"\"\"\n    Download PRISM data\n\n    Parameters:\n    bbox: [west, south, east, north]\n    year: data year or 'normals' for 30-year averages\n    variable: 'ppt', 'tmin', 'tmax', 'tmean', 'tdmean', 'vpdmin', 'vpdmax'\n    temporal: 'monthly', 'daily', 'annual'\n    \"\"\"\n\n    if year == 'normals':\n        base_url = \"https://prism.oregonstate.edu/normals/\"\n    else:\n        base_url = \"https://prism.oregonstate.edu/recent_years/\"\n\n    # PRISM requires spatial subsetting after download\n    # Full datasets available at: ftp://prism.oregonstate.edu/\n\n    print(f\"PRISM data download instructions:\")\n    print(f\"1. Visit: {base_url}\")\n    print(f\"2. Download {variable} data for {year}\")\n    print(f\"3. Use gdal_translate to subset:\")\n    print(f\"   gdal_translate -projwin {bbox[0]} {bbox[3]} {bbox[2]} {bbox[1]} input.bil output.tif\")\n\n# Example usage\ndownload_prism([-111.5, 32.0, -110.5, 32.5], 2020, 'ppt')\n</code></pre>"},{"location":"data-sources/#gridmet","title":"GridMET","text":"<p>Best for: Daily meteorological data with broader spatial coverage than DAYMET</p> <pre><code>import xarray as xr\n\ndef download_gridmet(bbox, year, variable='pr'):\n    \"\"\"\n    Download GridMET data\n\n    Parameters:  \n    bbox: [west, south, east, north]\n    year: data year\n    variable: 'pr', 'tmmn', 'tmmx', 'rmax', 'rmin', 'vs', 'th', 'pet', 'erc', 'bi', 'fm100', 'fm1000'\n    \"\"\"\n\n    base_url = \"http://thredds.northwestknowledge.net:8080/thredds/dodsC/MET\"\n    nc_url = f\"{base_url}/{variable}/{variable}_{year}.nc\"\n\n    # Open dataset\n    ds = xr.open_dataset(nc_url)\n\n    # Subset to bounding box\n    subset = ds.sel(\n        lon=slice(bbox[0], bbox[2]),\n        lat=slice(bbox[1], bbox[3])\n    )\n\n    return subset\n\n# Example usage\nbbox = [-111.5, 32.0, -110.5, 32.5]\nprecip_data = download_gridmet(bbox, 2020, 'pr')\n</code></pre>"},{"location":"data-sources/#satellite-data","title":"Satellite Data","text":""},{"location":"data-sources/#landsat-vegetation-indices","title":"Landsat (Vegetation Indices)","text":"<p>Best for: Long-term vegetation monitoring, NDVI calculation</p>"},{"location":"data-sources/#google-earth-engine-access","title":"Google Earth Engine Access","text":"<pre><code>import ee\n\nee.Initialize()\n\ndef get_landsat_collection(bbox, start_date, end_date, cloud_cover=20):\n    \"\"\"\n    Get Landsat collection with cloud masking\n    \"\"\"\n\n    # Define area of interest\n    aoi = ee.Geometry.Rectangle(bbox)\n\n    # Get Landsat 8 collection\n    collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \\\n        .filterBounds(aoi) \\\n        .filterDate(start_date, end_date) \\\n        .filter(ee.Filter.lt('CLOUD_COVER', cloud_cover))\n\n    def mask_clouds(image):\n        # Cloud mask using QA_PIXEL band\n        qa = image.select('QA_PIXEL')\n        cloud_mask = qa.bitwiseAnd(1 &lt;&lt; 3).eq(0)  # Cloud bit\n        return image.updateMask(cloud_mask)\n\n    # Apply cloud masking\n    masked_collection = collection.map(mask_clouds)\n\n    return masked_collection\n\ndef calculate_ndvi(image):\n    \"\"\"Calculate NDVI from Landsat image\"\"\"\n    ndvi = image.normalizedDifference(['SR_B5', 'SR_B4']).rename('NDVI')\n    return image.addBands(ndvi)\n\n# Example usage\nbbox = [-111.5, 32.0, -110.5, 32.5]\ncollection = get_landsat_collection(bbox, '2020-01-01', '2020-12-31')\nndvi_collection = collection.map(calculate_ndvi)\n\n# Get median NDVI for year\nmedian_ndvi = ndvi_collection.select('NDVI').median()\n</code></pre>"},{"location":"data-sources/#direct-archive-access","title":"Direct Archive Access","text":"<pre><code>import pystac_client\nimport rioxarray\n\n# Access Landsat via STAC\ncatalog = pystac_client.Client.open(\"https://landsatlook.usgs.gov/stac-server\")\n\n# Search for Landsat scenes\nsearch = catalog.search(\n    collections=[\"landsat-c2l2-sr\"],\n    bbox=[-111.5, 32.0, -110.5, 32.5],\n    datetime=\"2020-06-01/2020-08-31\",\n    query={\"eo:cloud_cover\": {\"lt\": 20}}\n)\n\n# Download and process\nitems = list(search.get_items())\nfor item in items[:5]:  # First 5 scenes\n    red_asset = item.assets['red']\n    nir_asset = item.assets['nir08']\n\n    # Load bands\n    red = rioxarray.open_rasterio(red_asset.href, chunks=True)\n    nir = rioxarray.open_rasterio(nir_asset.href, chunks=True)\n\n    # Calculate NDVI\n    ndvi = (nir - red) / (nir + red)\n</code></pre>"},{"location":"data-sources/#modis-products","title":"MODIS Products","text":"<p>Best for: Global vegetation monitoring, LAI/FPAR products</p> <pre><code>import requests\nfrom pyhdf.SD import SD, SDC\nimport numpy as np\n\ndef download_modis_lai(bbox, year, product='MYD15A3H'):\n    \"\"\"\n    Download MODIS LAI product\n\n    Parameters:\n    bbox: [west, south, east, north] \n    year: data year\n    product: 'MOD15A3H' (Terra) or 'MYD15A3H' (Aqua)\n    \"\"\"\n\n    # MODIS data requires registration at:\n    # https://urs.earthdata.nasa.gov/\n\n    base_url = \"https://e4ftl01.cr.usgs.gov/MOLA/\"\n\n    # Example for automated access (requires authentication)\n    print(f\"MODIS {product} download:\")\n    print(f\"1. Register at: https://urs.earthdata.nasa.gov/\")\n    print(f\"2. Use wget with credentials:\")\n    print(f\"   wget --user=USERNAME --password=PASSWORD {base_url}{product}\")\n    print(f\"3. Process HDF files to extract LAI layer\")\n\n# Process MODIS HDF file\ndef extract_modis_lai(hdf_file):\n    \"\"\"Extract LAI from MODIS HDF file\"\"\"\n\n    # Open HDF file\n    hdf = SD(hdf_file, SDC.READ)\n\n    # Get LAI dataset\n    lai_dataset = hdf.select('Lai_500m')\n    lai_data = lai_dataset.get()\n\n    # Apply scale factor and fill values\n    scale_factor = lai_dataset.attributes()['scale_factor']\n    fill_value = lai_dataset.attributes()['_FillValue']\n\n    lai_data = lai_data.astype(np.float32)\n    lai_data[lai_data == fill_value] = np.nan\n    lai_data = lai_data * scale_factor\n\n    return lai_data\n</code></pre>"},{"location":"data-sources/#data-integration-workflows","title":"Data Integration Workflows","text":""},{"location":"data-sources/#automated-climate-data-download","title":"Automated Climate Data Download","text":"<pre><code>import os\nimport subprocess\nfrom datetime import datetime, timedelta\n\nclass ClimateDataManager:\n    \"\"\"Automated climate data download and processing\"\"\"\n\n    def __init__(self, study_area, output_dir):\n        self.bbox = study_area  # [west, south, east, north]\n        self.output_dir = output_dir\n        os.makedirs(output_dir, exist_ok=True)\n\n    def download_daymet_timeseries(self, start_year, end_year, variables):\n        \"\"\"Download DAYMET time series for study area\"\"\"\n\n        for year in range(start_year, end_year + 1):\n            for var in variables:\n                url = f\"https://thredds.daac.ornl.gov/thredds/fileServer/ornldaac/1328/daymet_v4_daily_na_{var}_{year}.nc\"\n                output_file = f\"{self.output_dir}/daymet_{var}_{year}.nc\"\n\n                if not os.path.exists(output_file):\n                    print(f\"Downloading {var} for {year}...\")\n                    subprocess.run([\n                        'wget', '-O', output_file, url\n                    ], check=True)\n\n    def process_to_monthly(self, variables):\n        \"\"\"Convert daily DAYMET to monthly averages\"\"\"\n\n        for var in variables:\n            # Use CDO (Climate Data Operators) if available\n            input_pattern = f\"{self.output_dir}/daymet_{var}_*.nc\"\n            output_file = f\"{self.output_dir}/daymet_{var}_monthly.nc\"\n\n            cmd = f\"cdo -monmean -mergetime {input_pattern} {output_file}\"\n            print(f\"Processing {var} to monthly: {cmd}\")\n            # subprocess.run(cmd, shell=True, check=True)\n\n# Example usage\nstudy_area = [-111.5, 32.0, -110.5, 32.5]  # Arizona region\nclimate_manager = ClimateDataManager(study_area, 'climate_data')\n\n# Download 5 years of data\nclimate_manager.download_daymet_timeseries(2015, 2020, ['tmin', 'tmax', 'prcp', 'vp'])\nclimate_manager.process_to_monthly(['tmin', 'tmax', 'prcp', 'vp'])\n</code></pre>"},{"location":"data-sources/#data-quality-control","title":"Data Quality Control","text":"<pre><code>import rasterio\nimport numpy as np\nfrom rasterio.mask import mask\nimport geopandas as gpd\n\ndef validate_dataset(filepath, data_type='elevation'):\n    \"\"\"Validate downloaded dataset for quality issues\"\"\"\n\n    with rasterio.open(filepath) as src:\n        data = src.read(1)\n        profile = src.profile\n\n        results = {\n            'file': filepath,\n            'crs': profile['crs'],\n            'shape': data.shape,\n            'dtype': profile['dtype'],\n            'nodata': profile.get('nodata'),\n            'valid_pixels': np.sum(~np.isnan(data)),\n            'coverage_pct': np.sum(~np.isnan(data)) / data.size * 100\n        }\n\n        if data_type == 'elevation':\n            results.update({\n                'elevation_min': np.nanmin(data),\n                'elevation_max': np.nanmax(data),\n                'elevation_mean': np.nanmean(data),\n                'has_negative_elev': np.any(data &lt; -500),  # Flag suspicious values\n            })\n        elif data_type == 'temperature':\n            results.update({\n                'temp_min': np.nanmin(data),\n                'temp_max': np.nanmax(data), \n                'temp_mean': np.nanmean(data),\n                'realistic_range': np.all((data &gt;= -50) &amp; (data &lt;= 60))  # Celsius range\n            })\n        elif data_type == 'precipitation':\n            results.update({\n                'precip_min': np.nanmin(data),\n                'precip_max': np.nanmax(data),\n                'precip_mean': np.nanmean(data),\n                'no_negative': np.all(data &gt;= 0)  # Precipitation can't be negative\n            })\n\n        return results\n\n# Validate all datasets\ndatasets = [\n    ('dem.tif', 'elevation'),\n    ('temperature.tif', 'temperature'), \n    ('precipitation.tif', 'precipitation')\n]\n\nfor filepath, data_type in datasets:\n    if os.path.exists(filepath):\n        validation = validate_dataset(filepath, data_type)\n        print(f\"\\n{filepath} validation:\")\n        for key, value in validation.items():\n            print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"data-sources/#best-practices","title":"Best Practices","text":""},{"location":"data-sources/#data-selection-guidelines","title":"Data Selection Guidelines","text":"<ol> <li>Match spatial resolutions - Use consistent pixel sizes across datasets</li> <li>Align temporal periods - Ensure climate data covers the same time period  </li> <li>Check coordinate systems - Reproject data to common CRS if needed</li> <li>Validate extents - Confirm all datasets cover your study area completely</li> </ol>"},{"location":"data-sources/#storage-and-organization","title":"Storage and Organization","text":"<pre><code>project/\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 elevation/\n\u2502   \u2502   \u251c\u2500\u2500 raw/           # Original downloads\n\u2502   \u2502   \u251c\u2500\u2500 processed/     # Reprojected, clipped\n\u2502   \u2502   \u2514\u2500\u2500 metadata/      # Data provenance\n\u2502   \u251c\u2500\u2500 climate/\n\u2502   \u2502   \u251c\u2500\u2500 daymet/        # Daily meteorology  \n\u2502   \u2502   \u251c\u2500\u2500 prism/         # Monthly normals\n\u2502   \u2502   \u2514\u2500\u2500 processed/     # Analysis-ready\n\u2502   \u2514\u2500\u2500 satellite/\n\u2502       \u251c\u2500\u2500 landsat/       # Vegetation indices\n\u2502       \u2514\u2500\u2500 modis/         # LAI products\n\u251c\u2500\u2500 scripts/               # Download automation\n\u2514\u2500\u2500 docs/                  # Data documentation\n</code></pre>"},{"location":"data-sources/#performance-tips","title":"Performance Tips","text":"<ul> <li>Use parallel downloads for large datasets</li> <li>Compress intermediate files (LZW compression) </li> <li>Tile large rasters for memory-efficient processing</li> <li>Cache frequently used data locally</li> <li>Document data provenance for reproducibility</li> </ul> <p>Next: GRASS GIS Setup and Configuration</p>"},{"location":"development/","title":"Development Guide","text":""},{"location":"development/#contributing-to-eemt","title":"Contributing to EEMT","text":"<p>We welcome contributions to improve EEMT calculations, add new features, and extend documentation. This guide covers the development process and technical architecture.</p>"},{"location":"development/#quick-start-for-developers","title":"Quick Start for Developers","text":""},{"location":"development/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code>git clone https://github.com/your-username/eemt.git\ncd eemt\ngit checkout 2020_update\n</code></pre>"},{"location":"development/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code># Create virtual environment\npython -m venv eemt-dev\nsource eemt-dev/bin/activate\n\n# Install development dependencies\npip install -r requirements.txt\npip install -e .\n</code></pre>"},{"location":"development/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Unit tests\npytest tests/\n\n# Integration tests  \nbash tests/integration_tests.sh\n\n# Documentation tests\nmkdocs serve\n</code></pre>"},{"location":"development/#development-workflow","title":"Development Workflow","text":""},{"location":"development/#branch-strategy","title":"Branch Strategy","text":"<ul> <li>master: Stable releases</li> <li>2020_update: Active development branch</li> <li>feature/*: New feature development</li> <li>hotfix/*: Critical bug fixes</li> </ul>"},{"location":"development/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create feature branch <pre><code>git checkout -b feature/new-climate-data-source\n</code></pre></p> </li> <li> <p>Make changes with tests <pre><code># Add new functionality\ndef new_climate_function():\n    pass\n\n# Add corresponding tests\ndef test_new_climate_function():\n    pass\n</code></pre></p> </li> <li> <p>Update documentation <pre><code>## New Climate Data Source\n\nDescription of new functionality...\n</code></pre></p> </li> <li> <p>Submit pull request</p> </li> <li>Include clear description</li> <li>Reference any related issues</li> <li>Ensure tests pass</li> </ol>"},{"location":"development/#code-standards","title":"Code Standards","text":""},{"location":"development/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8 guidelines</li> <li>Use type hints for function signatures</li> <li>Maximum line length: 88 characters</li> <li>Use Black for code formatting</li> </ul> <pre><code>from typing import Optional, Tuple\nimport numpy as np\n\ndef calculate_eemt(\n    temperature: np.ndarray, \n    precipitation: np.ndarray,\n    elevation: Optional[np.ndarray] = None\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Calculate EEMT with proper typing.\"\"\"\n    pass\n</code></pre>"},{"location":"development/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use Google-style docstrings</li> <li>Include examples in docstrings</li> <li>Update relevant documentation pages</li> <li>Add entries to changelog</li> </ul>"},{"location":"development/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Unit tests for all new functions</li> <li>Integration tests for workflows</li> <li>Performance benchmarks for algorithms</li> <li>Validation against scientific literature</li> </ul>"},{"location":"development/#architecture-overview","title":"Architecture Overview","text":""},{"location":"development/#core-components","title":"Core Components","text":"<pre><code>graph TD\n    A[Data Sources] --&gt; B[Preprocessing]\n    B --&gt; C[GRASS GIS Processing]\n    C --&gt; D[EEMT Calculations]\n    D --&gt; E[Output &amp; Validation]\n\n    A1[DAYMET API] --&gt; A\n    A2[USGS 3DEP] --&gt; A\n    A3[OpenTopography] --&gt; A\n    A4[Satellite Data] --&gt; A\n\n    C1[r.sun Solar] --&gt; C\n    C2[r.slope.aspect] --&gt; C\n    C3[r.watershed] --&gt; C\n\n    D1[Traditional EEMT] --&gt; D\n    D2[Topographic EEMT] --&gt; D\n    D3[Vegetation EEMT] --&gt; D</code></pre>"},{"location":"development/#module-structure","title":"Module Structure","text":"<pre><code>eemt/\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 calculations.py     # Core EEMT functions\n\u2502   \u251c\u2500\u2500 constants.py        # Physical constants\n\u2502   \u2514\u2500\u2500 validation.py       # Result validation\n\u251c\u2500\u2500 data_sources/\n\u2502   \u251c\u2500\u2500 elevation.py        # DEM access functions\n\u2502   \u251c\u2500\u2500 climate.py          # Climate data APIs\n\u2502   \u2514\u2500\u2500 satellite.py        # Remote sensing data\n\u251c\u2500\u2500 grass_interface/\n\u2502   \u251c\u2500\u2500 solar.py           # r.sun wrapper functions\n\u2502   \u251c\u2500\u2500 terrain.py         # Terrain analysis\n\u2502   \u2514\u2500\u2500 parallel.py        # Parallel processing\n\u251c\u2500\u2500 workflows/\n\u2502   \u251c\u2500\u2500 traditional.py     # Traditional EEMT\n\u2502   \u251c\u2500\u2500 topographic.py     # Topographic EEMT\n\u2502   \u2514\u2500\u2500 vegetation.py      # Vegetation EEMT\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 io.py              # File I/O utilities\n    \u251c\u2500\u2500 projections.py     # CRS handling\n    \u2514\u2500\u2500 performance.py     # Performance monitoring\n</code></pre>"},{"location":"development/#performance-considerations","title":"Performance Considerations","text":""},{"location":"development/#optimization-guidelines","title":"Optimization Guidelines","text":"<ol> <li>Memory Management</li> <li>Process large datasets in chunks</li> <li>Use memory-mapped arrays when possible</li> <li> <p>Clean up temporary files promptly</p> </li> <li> <p>Parallel Processing</p> </li> <li>Maximize CPU utilization with multiprocessing</li> <li>Use thread-safe operations</li> <li> <p>Balance memory vs. speed tradeoffs</p> </li> <li> <p>I/O Optimization</p> </li> <li>Use compressed file formats (LZW, DEFLATE)</li> <li>Implement caching for repeated operations</li> <li>Minimize network requests</li> </ol>"},{"location":"development/#benchmarking","title":"Benchmarking","text":"<pre><code>import time\nimport psutil\nfrom functools import wraps\n\ndef benchmark(func):\n    \"\"\"Decorator for performance benchmarking\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        start_memory = psutil.Process().memory_info().rss\n\n        result = func(*args, **kwargs)\n\n        end_time = time.time()\n        end_memory = psutil.Process().memory_info().rss\n\n        print(f\"{func.__name__} performance:\")\n        print(f\"  Time: {end_time - start_time:.2f} seconds\")\n        print(f\"  Memory: {(end_memory - start_memory) / 1024**2:.1f} MB\")\n\n        return result\n    return wrapper\n</code></pre>"},{"location":"development/#testing-framework","title":"Testing Framework","text":""},{"location":"development/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 test_calculations.py\n\u2502   \u251c\u2500\u2500 test_data_sources.py\n\u2502   \u2514\u2500\u2500 test_grass_interface.py\n\u251c\u2500\u2500 integration/\n\u2502   \u251c\u2500\u2500 test_workflows.py\n\u2502   \u2514\u2500\u2500 test_end_to_end.py\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 sample_dem.tif\n\u2502   \u2514\u2500\u2500 sample_climate.nc\n\u2514\u2500\u2500 conftest.py\n</code></pre>"},{"location":"development/#example-test","title":"Example Test","text":"<pre><code>import pytest\nimport numpy as np\nfrom eemt.core.calculations import calculate_eemt_traditional\n\ndef test_eemt_traditional_basic():\n    \"\"\"Test basic traditional EEMT calculation\"\"\"\n\n    # Test data\n    temp = np.array([15.0, 20.0, 25.0])  # \u00b0C\n    precip = np.array([50.0, 40.0, 30.0])  # mm\n\n    # Calculate EEMT\n    eemt, e_bio, e_ppt = calculate_eemt_traditional(temp, precip)\n\n    # Assertions\n    assert isinstance(eemt, np.ndarray)\n    assert np.all(eemt &gt;= 0), \"EEMT should be non-negative\"\n    assert np.all(e_bio &gt;= 0), \"E_BIO should be non-negative\"\n    assert np.all(e_ppt &gt;= 0), \"E_PPT should be non-negative\"\n    assert np.allclose(eemt, e_bio + e_ppt), \"EEMT should equal sum of components\"\n\n@pytest.mark.integration\ndef test_complete_workflow():\n    \"\"\"Test complete EEMT workflow with sample data\"\"\"\n\n    from eemt.workflows import run_complete_eemt_pipeline\n\n    # Use test data\n    result = run_complete_eemt_pipeline(\n        dem_file='tests/data/sample_dem.tif',\n        climate_dir='tests/data/climate/',\n        output_dir='tests/output/',\n        start_year=2015,\n        end_year=2015  # Single year for speed\n    )\n\n    assert 'traditional' in result\n    assert np.any(~np.isnan(result['traditional']))\n</code></pre>"},{"location":"development/#documentation-development","title":"Documentation Development","text":""},{"location":"development/#mkdocs-setup","title":"MkDocs Setup","text":"<pre><code># Serve documentation locally\nmkdocs serve\n\n# Build static site\nmkdocs build\n\n# Deploy to GitHub Pages\nmkdocs gh-deploy\n</code></pre>"},{"location":"development/#writing-guidelines","title":"Writing Guidelines","text":"<ol> <li>Structure: Use clear headings and subheadings</li> <li>Examples: Include working code examples</li> <li>Math: Use MathJax for equations</li> <li>Images: Optimize for web display</li> <li>Links: Use relative links within documentation</li> </ol>"},{"location":"development/#documentation-testing","title":"Documentation Testing","text":"<pre><code># Check for broken links\npytest docs/test_docs.py\n\n# Validate markdown syntax\nmarkdownlint docs/\n\n# Check MkDocs configuration\nmkdocs build --strict\n</code></pre>"},{"location":"development/#release-process","title":"Release Process","text":""},{"location":"development/#version-numbering","title":"Version Numbering","text":"<ul> <li>Major: Breaking API changes (2.0.0)</li> <li>Minor: New features, backwards compatible (2.1.0)</li> <li>Patch: Bug fixes (2.1.1)</li> </ul>"},{"location":"development/#release-checklist","title":"Release Checklist","text":"<ol> <li> <p>Update version numbers <pre><code># eemt/__init__.py\n__version__ = \"2.1.0\"\n</code></pre></p> </li> <li> <p>Update changelog <pre><code>## [2.1.0] - 2025-01-15\n### Added\n- New climate data source integration\n### Fixed\n- Memory optimization for large datasets\n</code></pre></p> </li> <li> <p>Run full test suite <pre><code>pytest tests/ --cov=eemt\n</code></pre></p> </li> <li> <p>Build and test documentation <pre><code>mkdocs build --strict\n</code></pre></p> </li> <li> <p>Create release tag <pre><code>git tag -a v2.1.0 -m \"Release version 2.1.0\"\ngit push origin v2.1.0\n</code></pre></p> </li> </ol>"},{"location":"development/#getting-help","title":"Getting Help","text":""},{"location":"development/#development-support","title":"Development Support","text":"<ul> <li>GitHub Issues: Technical questions and bug reports</li> <li>GitHub Discussions: Design discussions and feature requests</li> <li>Email: Direct contact with maintainers</li> </ul>"},{"location":"development/#code-review-process","title":"Code Review Process","text":"<ul> <li>All changes require review by core maintainers</li> <li>Automated testing must pass</li> <li>Documentation must be updated</li> <li>Performance impacts should be evaluated</li> </ul> <p>Ready to contribute? Check the sections above for detailed development instructions.</p>"},{"location":"examples/","title":"EEMT Calculation Examples","text":""},{"location":"examples/#overview","title":"Overview","text":"<p>This section provides complete, working examples for EEMT calculations across different study areas and use cases, integrating public datasets with the GRASS GIS parallel processing framework.</p>"},{"location":"examples/#example-1-arizona-sky-islands-analysis","title":"Example 1: Arizona Sky Islands Analysis","text":""},{"location":"examples/#study-area-santa-catalina-mountains","title":"Study Area: Santa Catalina Mountains","text":"<p>Based on the validation case study from Rasmussen et al. (2014).</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nArizona Sky Islands EEMT Analysis\nReplicating Rasmussen et al. (2014) study with modern tools\n\"\"\"\n\nimport numpy as np\nimport rasterio\nimport xarray as xr\nfrom pathlib import Path\n\n# Study area definition\nSTUDY_AREA = {\n    'name': 'Santa Catalina Mountains',\n    'bbox': [-110.95, 32.35, -110.70, 32.45],  # [west, south, east, north]\n    'elevation_range': [800, 2800],  # meters\n    'climate_zones': ['desert_scrub', 'oak_woodland', 'pine_forest', 'mixed_conifer']\n}\n\ndef arizona_eemt_example():\n    \"\"\"Complete Arizona EEMT analysis example\"\"\"\n\n    project_dir = Path('arizona_eemt_example')\n    project_dir.mkdir(exist_ok=True)\n\n    print(\"=== Arizona Sky Islands EEMT Analysis ===\")\n    print(f\"Study area: {STUDY_AREA['name']}\")\n    print(f\"Bounding box: {STUDY_AREA['bbox']}\")\n\n    # Step 1: Download data\n    print(\"\\\\n1. Downloading elevation data...\")\n\n    # Use OpenTopography for this region\n    from docs.data_sources import download_opentopo\n    dem_file = download_opentopo(STUDY_AREA['bbox'], 'SRTMGL1')\n\n    # Download higher resolution USGS data if available\n    try:\n        from docs.data_sources import download_3dep\n        dem_high_res = download_3dep(STUDY_AREA['bbox'], '10m')\n        if dem_high_res:\n            dem_file = dem_high_res\n            print(\"\u2713 Using 10m USGS elevation data\")\n    except:\n        print(\"\u2713 Using 30m SRTM elevation data\")\n\n    # Step 2: Download climate data\n    print(\"\\\\n2. Downloading DAYMET climate data...\")\n\n    climate_dir = project_dir / 'climate'\n    climate_dir.mkdir(exist_ok=True)\n\n    # Download 5 years of DAYMET data\n    for year in range(2015, 2020):\n        for variable in ['tmin', 'tmax', 'prcp', 'vp']:\n            url = f\"https://thredds.daac.ornl.gov/thredds/fileServer/ornldaac/1328/daymet_v4_daily_na_{variable}_{year}.nc\"\n            output_file = climate_dir / f\"daymet_{variable}_{year}.nc\"\n\n            if not output_file.exists():\n                print(f\"  Downloading {variable} {year}...\")\n                # Download implementation here\n\n    # Step 3: Download vegetation data\n    print(\"\\\\n3. Downloading Landsat NDVI data...\")\n\n    # Use Google Earth Engine or USGS API\n    # Implementation for Landsat NDVI download\n\n    # Step 4: Run EEMT calculations\n    print(\"\\\\n4. Running EEMT calculations...\")\n\n    # Traditional EEMT\n    eemt_trad = calculate_traditional_eemt(\n        dem_file, climate_dir, project_dir / 'eemt_traditional.tif'\n    )\n\n    # Topographic EEMT  \n    eemt_topo = calculate_topographic_eemt(\n        dem_file, climate_dir, project_dir / 'eemt_topographic.tif'\n    )\n\n    # Vegetation EEMT\n    eemt_veg = calculate_vegetation_eemt(\n        dem_file, climate_dir, project_dir / 'eemt_vegetation.tif',\n        ndvi_file=project_dir / 'landsat_ndvi.tif'\n    )\n\n    # Step 5: Analysis and validation\n    print(\"\\\\n5. Analyzing results...\")\n\n    # Load results for comparison\n    with rasterio.open(project_dir / 'eemt_traditional.tif') as src:\n        eemt_trad_data = src.read(1)\n    with rasterio.open(project_dir / 'eemt_topographic.tif') as src:\n        eemt_topo_data = src.read(1)\n    with rasterio.open(project_dir / 'eemt_vegetation.tif') as src:\n        eemt_veg_data = src.read(1)\n\n    # Generate summary statistics\n    methods = {\n        'Traditional': eemt_trad_data,\n        'Topographic': eemt_topo_data, \n        'Vegetation': eemt_veg_data\n    }\n\n    print(\"\\\\nEEMT Summary by Method:\")\n    print(\"-\" * 50)\n    for method, data in methods.items():\n        print(f\"{method:12} | Mean: {np.nanmean(data):6.1f} | Std: {np.nanstd(data):5.1f} | Range: {np.nanmin(data):5.1f}-{np.nanmax(data):5.1f} MJ/m\u00b2/yr\")\n\n    # Aspect analysis (north vs south slopes)\n    with rasterio.open(dem_file) as src:\n        elevation = src.read(1)\n\n    # Calculate aspect using GDAL\n    import subprocess\n    aspect_file = project_dir / 'aspect.tif'\n    subprocess.run([\n        'gdaldem', 'aspect', str(dem_file), str(aspect_file)\n    ], check=True)\n\n    with rasterio.open(aspect_file) as src:\n        aspect = src.read(1)\n\n    # Define north vs south facing slopes\n    north_mask = (aspect &gt;= 315) | (aspect &lt;= 45)  # North-facing \u00b145\u00b0\n    south_mask = (aspect &gt;= 135) &amp; (aspect &lt;= 225)  # South-facing \u00b145\u00b0\n\n    print(\"\\\\nAspect Analysis:\")\n    print(\"-\" * 30)\n    for method, data in methods.items():\n        north_mean = np.nanmean(data[north_mask])\n        south_mean = np.nanmean(data[south_mask])\n        difference = north_mean - south_mean\n        print(f\"{method:12} | North: {north_mean:5.1f} | South: {south_mean:5.1f} | Diff: {difference:+5.1f} MJ/m\u00b2/yr\")\n\n    # Elevation gradient analysis\n    elevation_bins = np.arange(800, 2800, 200)\n\n    print(\"\\\\nElevation Gradient Analysis:\")\n    print(\"-\" * 40)\n    print(\"Elevation   | Traditional | Topographic | Vegetation\")\n    print(\"-\" * 40)\n\n    for i in range(len(elevation_bins)-1):\n        elev_mask = (elevation &gt;= elevation_bins[i]) &amp; (elevation &lt; elevation_bins[i+1])\n\n        if np.sum(elev_mask) &gt; 100:  # Sufficient pixels\n            trad_mean = np.nanmean(eemt_trad_data[elev_mask])\n            topo_mean = np.nanmean(eemt_topo_data[elev_mask])\n            veg_mean = np.nanmean(eemt_veg_data[elev_mask])\n\n            print(f\"{elevation_bins[i]:4.0f}-{elevation_bins[i+1]:4.0f}m | {trad_mean:10.1f} | {topo_mean:10.1f} | {veg_mean:9.1f}\")\n\n    print(f\"\\\\n\u2713 Arizona Sky Islands analysis completed\")\n    print(f\"Results saved to: {project_dir}\")\n\nif __name__ == '__main__':\n    arizona_eemt_example()\n</code></pre>"},{"location":"examples/#example-2-large-watershed-analysis","title":"Example 2: Large Watershed Analysis","text":""},{"location":"examples/#multi-scale-eemt-calculation","title":"Multi-Scale EEMT Calculation","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nLarge Watershed EEMT Analysis\nDemonstrates tiled processing for continental-scale applications\n\"\"\"\n\nimport numpy as np\nfrom pathlib import Path\nimport multiprocessing as mp\n\ndef large_watershed_example():\n    \"\"\"\n    Large watershed EEMT calculation example\n    Demonstrates handling of large spatial extents\n    \"\"\"\n\n    # Colorado River Basin example\n    STUDY_AREA = {\n        'name': 'Colorado River Basin',\n        'bbox': [-114.0, 32.0, -106.0, 42.0],  # Large region\n        'tile_size': 1.0,  # 1 degree tiles\n        'years': [2010, 2020]\n    }\n\n    project_dir = Path('colorado_river_eemt')\n    project_dir.mkdir(exist_ok=True)\n\n    print(\"=== Large Watershed EEMT Analysis ===\")\n    print(f\"Study area: {STUDY_AREA['name']}\")\n    print(f\"Spatial extent: {STUDY_AREA['bbox']}\")\n\n    # Step 1: Create processing tiles\n    print(\"\\\\n1. Creating processing tiles...\")\n\n    west, south, east, north = STUDY_AREA['bbox']\n    tile_size = STUDY_AREA['tile_size']\n\n    tiles = []\n    tile_id = 0\n\n    for lat in np.arange(south, north, tile_size):\n        for lon in np.arange(west, east, tile_size):\n\n            tile_bbox = [lon, lat, lon + tile_size, lat + tile_size]\n            tiles.append({\n                'id': tile_id,\n                'bbox': tile_bbox,\n                'center': [lon + tile_size/2, lat + tile_size/2]\n            })\n            tile_id += 1\n\n    print(f\"Created {len(tiles)} processing tiles\")\n\n    # Step 2: Process tiles in parallel\n    print(\"\\\\n2. Processing tiles in parallel...\")\n\n    def process_tile(tile):\n        \"\"\"Process single tile\"\"\"\n\n        tile_dir = project_dir / f\"tile_{tile['id']:03d}\"\n        tile_dir.mkdir(exist_ok=True)\n\n        try:\n            # Download data for tile\n            dem_file = download_3dep(tile['bbox'], '30m')\n\n            # Download DAYMET data for tile\n            climate_files = download_daymet_spatial(\n                tile['bbox'], \n                range(STUDY_AREA['years'][0], STUDY_AREA['years'][1]+1),\n                ['tmin', 'tmax', 'prcp']\n            )\n\n            # Calculate EEMT for tile\n            from workflows import run_complete_eemt_pipeline\n\n            results = run_complete_eemt_pipeline(\n                dem_file,\n                tile_dir / 'results',\n                tile_dir / 'climate',\n                STUDY_AREA['years'][0], \n                STUDY_AREA['years'][1]\n            )\n\n            return tile['id'], True, tile_dir / 'results' / 'eemt_topographic.tif'\n\n        except Exception as e:\n            print(f\"Tile {tile['id']} failed: {e}\")\n            return tile['id'], False, None\n\n    # Process tiles in parallel\n    max_workers = min(mp.cpu_count(), 8)  # Limit concurrent downloads\n\n    with mp.Pool(max_workers) as pool:\n        tile_results = pool.map(process_tile, tiles)\n\n    # Step 3: Merge tile results\n    print(\"\\\\n3. Merging tile results...\")\n\n    successful_tiles = [result for result in tile_results if result[1]]\n    failed_tiles = [result for result in tile_results if not result[1]]\n\n    print(f\"Successful tiles: {len(successful_tiles)}\")\n    print(f\"Failed tiles: {len(failed_tiles)}\")\n\n    if successful_tiles:\n        # Merge using GDAL\n        tile_files = [str(result[2]) for result in successful_tiles]\n        merged_file = project_dir / 'colorado_river_eemt_merged.tif'\n\n        import subprocess\n        subprocess.run([\n            'gdal_merge.py', '-o', str(merged_file), '-co', 'COMPRESS=LZW'\n        ] + tile_files, check=True)\n\n        print(f\"\u2713 Merged results saved to: {merged_file}\")\n\n    return len(successful_tiles) &gt; 0\n\nif __name__ == '__main__':\n    large_watershed_example()\n</code></pre>"},{"location":"examples/#example-3-time-series-analysis","title":"Example 3: Time Series Analysis","text":""},{"location":"examples/#multi-decade-eemt-trends","title":"Multi-Decade EEMT Trends","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nTime Series EEMT Analysis\nCalculate long-term trends and climate change effects\n\"\"\"\n\nimport numpy as np\nimport xarray as xr\nimport matplotlib.pyplot as plt\nfrom scipy import stats\nimport pandas as pd\n\ndef time_series_eemt_example():\n    \"\"\"\n    Multi-decade EEMT time series analysis\n    Demonstrates climate change impact assessment\n    \"\"\"\n\n    # Example: Western US mountain region\n    STUDY_AREA = {\n        'name': 'Rocky Mountain National Park',\n        'bbox': [-105.8, 40.1, -105.5, 40.5],\n        'years': [1980, 2023],  # Full DAYMET record\n        'elevation_bands': [2000, 2500, 3000, 3500]  # Analyze by elevation zone\n    }\n\n    project_dir = Path('rocky_mountain_time_series')\n    project_dir.mkdir(exist_ok=True)\n\n    print(\"=== Multi-Decade EEMT Time Series Analysis ===\")\n    print(f\"Study area: {STUDY_AREA['name']}\")\n    print(f\"Time period: {STUDY_AREA['years'][0]}-{STUDY_AREA['years'][1]} ({STUDY_AREA['years'][1] - STUDY_AREA['years'][0] + 1} years)\")\n\n    # Step 1: Download multi-decade climate data\n    print(\"\\\\n1. Downloading multi-decade climate data...\")\n\n    climate_data = {}\n    years = range(STUDY_AREA['years'][0], STUDY_AREA['years'][1] + 1)\n\n    for variable in ['tmin', 'tmax', 'prcp']:\n\n        # Download and concatenate all years\n        annual_files = []\n        for year in years:\n            url = f\"https://thredds.daac.ornl.gov/thredds/dodsC/ornldaac/1328/daymet_v4_daily_na_{variable}_{year}.nc\"\n\n            # Subset to study area\n            ds = xr.open_dataset(url)\n            bbox = STUDY_AREA['bbox']\n            subset = ds.sel(x=slice(bbox[0], bbox[2]), y=slice(bbox[1], bbox[3]))\n            annual_files.append(subset)\n\n        # Concatenate all years\n        climate_data[variable] = xr.concat(annual_files, dim='time')\n        print(f\"\u2713 {variable}: {len(years)} years loaded\")\n\n    # Step 2: Calculate annual EEMT time series\n    print(\"\\\\n2. Calculating annual EEMT time series...\")\n\n    # Resample to annual means\n    annual_climate = {}\n    for var, data in climate_data.items():\n        annual_climate[var] = data.resample(time='1Y').mean()\n\n    # Calculate EEMT for each year\n    eemt_time_series = []\n\n    for year_idx in range(len(years)):\n\n        year = years[year_idx]\n        print(f\"  Processing year {year}...\")\n\n        # Extract climate for this year\n        temp_mean = (annual_climate['tmin'].isel(time=year_idx) + \n                    annual_climate['tmax'].isel(time=year_idx)) / 2\n        precip = annual_climate['prcp'].isel(time=year_idx)\n\n        # Simple EEMT calculation (traditional method)\n        # Calculate PET (simplified Hamon)\n        temp_celsius = temp_mean.values - 273.15\n        pet = 0.0023 * (temp_celsius + 17.8) * np.sqrt(np.maximum(0, temp_celsius)) * 58.93\n\n        # Effective precipitation\n        effective_precip = np.maximum(0, precip.values - pet)\n\n        # NPP (Lieth method)\n        npp = np.where(temp_celsius &gt; 0, \n                      3000 * (1 - np.exp(1.315 - 0.119 * temp_celsius))**(-1),\n                      0)\n\n        # EEMT components\n        h_bio = 22e6  # J/kg\n        c_w = 4180   # J/kg/K\n\n        e_bio = (npp / 1000) * h_bio / (365 * 24 * 3600)  # W/m\u00b2\n        e_ppt = (effective_precip / 1000) * c_w * np.maximum(0, temp_celsius) / (365 * 24 * 3600)\n\n        eemt = (e_bio + e_ppt) * 365 * 24 * 3600 / 1e6  # MJ/m\u00b2/yr\n\n        # Store results\n        eemt_time_series.append({\n            'year': year,\n            'eemt_mean': np.nanmean(eemt),\n            'eemt_std': np.nanstd(eemt),\n            'temp_mean': np.nanmean(temp_celsius),\n            'precip_mean': np.nanmean(precip.values),\n            'npp_mean': np.nanmean(npp)\n        })\n\n    # Step 3: Trend analysis\n    print(\"\\\\n3. Analyzing trends...\")\n\n    # Convert to DataFrame\n    df = pd.DataFrame(eemt_time_series)\n\n    # Calculate trends\n    trends = {}\n    for variable in ['eemt_mean', 'temp_mean', 'precip_mean', 'npp_mean']:\n        slope, intercept, r_value, p_value, std_err = stats.linregress(df['year'], df[variable])\n\n        trends[variable] = {\n            'slope': slope,\n            'r_squared': r_value**2,\n            'p_value': p_value,\n            'trend_per_decade': slope * 10\n        }\n\n    # Print trend analysis\n    print(\"\\\\nTrend Analysis (1980-2023):\")\n    print(\"-\" * 60)\n    print(f\"{'Variable':&lt;15} | {'Trend/Decade':&lt;12} | {'R\u00b2':&lt;6} | {'p-value':&lt;8}\")\n    print(\"-\" * 60)\n\n    trend_labels = {\n        'eemt_mean': 'EEMT',\n        'temp_mean': 'Temperature', \n        'precip_mean': 'Precipitation',\n        'npp_mean': 'NPP'\n    }\n\n    units = {\n        'eemt_mean': 'MJ/m\u00b2/yr',\n        'temp_mean': '\u00b0C',\n        'precip_mean': 'mm/yr', \n        'npp_mean': 'g/m\u00b2/yr'\n    }\n\n    for var, trend in trends.items():\n        label = trend_labels[var]\n        unit = units[var]\n        print(f\"{label:&lt;15} | {trend['trend_per_decade']:+8.3f} {unit:&lt;3} | {trend['r_squared']:&lt;6.3f} | {trend['p_value']:&lt;8.4f}\")\n\n    # Step 4: Generate visualizations\n    print(\"\\\\n4. Generating time series plots...\")\n\n    fig, axes = plt.subplots(2, 2, figsize=(12, 8))\n    fig.suptitle(f\"{STUDY_AREA['name']} EEMT Time Series (1980-2023)\")\n\n    # EEMT time series\n    axes[0,0].plot(df['year'], df['eemt_mean'], 'b-', linewidth=2)\n    axes[0,0].fill_between(df['year'], \n                          df['eemt_mean'] - df['eemt_std'],\n                          df['eemt_mean'] + df['eemt_std'], \n                          alpha=0.3)\n    axes[0,0].set_title('EEMT Time Series')\n    axes[0,0].set_ylabel('EEMT (MJ/m\u00b2/yr)')\n\n    # Temperature trend\n    axes[0,1].plot(df['year'], df['temp_mean'], 'r-', linewidth=2)\n    axes[0,1].set_title('Temperature Trend')\n    axes[0,1].set_ylabel('Temperature (\u00b0C)')\n\n    # Precipitation trend  \n    axes[1,0].plot(df['year'], df['precip_mean'], 'g-', linewidth=2)\n    axes[1,0].set_title('Precipitation Trend')\n    axes[1,0].set_ylabel('Precipitation (mm/yr)')\n\n    # NPP trend\n    axes[1,1].plot(df['year'], df['npp_mean'], 'orange', linewidth=2)\n    axes[1,1].set_title('NPP Trend')\n    axes[1,1].set_ylabel('NPP (g/m\u00b2/yr)')\n\n    for ax in axes.flat:\n        ax.grid(True, alpha=0.3)\n        ax.set_xlabel('Year')\n\n    plt.tight_layout()\n    plt.savefig(project_dir / 'eemt_time_series.png', dpi=300, bbox_inches='tight')\n    plt.show()\n\n    # Step 5: Climate sensitivity analysis\n    print(\"\\\\n5. Analyzing climate sensitivity...\")\n\n    # Calculate correlations between EEMT and climate drivers\n    correlations = {}\n    for climate_var in ['temp_mean', 'precip_mean']:\n        r, p = stats.pearsonr(df['eemt_mean'], df[climate_var])\n        correlations[climate_var] = {'correlation': r, 'p_value': p}\n\n    print(\"\\\\nEEMT-Climate Correlations:\")\n    print(\"-\" * 35)\n    for var, corr in correlations.items():\n        var_name = 'Temperature' if 'temp' in var else 'Precipitation'\n        print(f\"{var_name:&lt;13} | r={corr['correlation']:+6.3f} | p={corr['p_value']:&lt;6.4f}\")\n\n    # Save time series data\n    df.to_csv(project_dir / 'eemt_time_series.csv', index=False)\n\n    print(f\"\\\\n\u2713 Time series analysis completed\")\n    print(f\"Data saved to: {project_dir / 'eemt_time_series.csv'}\")\n    print(f\"Plots saved to: {project_dir / 'eemt_time_series.png'}\")\n\nif __name__ == '__main__':\n    time_series_eemt_example()\n</code></pre>"},{"location":"examples/#example-3-urban-heat-island-analysis","title":"Example 3: Urban Heat Island Analysis","text":""},{"location":"examples/#eemt-in-urban-environments","title":"EEMT in Urban Environments","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nUrban Heat Island EEMT Analysis\nDemonstrates EEMT application to urban environments\n\"\"\"\n\ndef urban_heat_island_example():\n    \"\"\"\n    Urban EEMT calculation example\n    Phoenix, Arizona metropolitan area\n    \"\"\"\n\n    STUDY_AREA = {\n        'name': 'Phoenix Metropolitan Area',\n        'bbox': [-112.5, 33.2, -111.5, 33.8],\n        'urban_center': [-112.0, 33.5],\n        'land_cover_classes': ['urban', 'desert', 'agriculture', 'mountain']\n    }\n\n    project_dir = Path('phoenix_urban_eemt')\n    project_dir.mkdir(exist_ok=True)\n\n    print(\"=== Urban Heat Island EEMT Analysis ===\")\n    print(f\"Study area: {STUDY_AREA['name']}\")\n\n    # Step 1: Download high-resolution data\n    print(\"\\\\n1. Downloading urban-scale data...\")\n\n    # High-resolution DEM for urban analysis\n    dem_file = download_3dep(STUDY_AREA['bbox'], '1m')  # 1m lidar if available\n\n    # Landsat thermal and optical data\n    landsat_data = download_landsat_collection(\n        STUDY_AREA['bbox'], \n        '2020-06-01', '2020-08-31',  # Summer period\n        ['red', 'nir', 'thermal']\n    )\n\n    # Urban land cover data\n    # Use NLCD (National Land Cover Database) for US\n    nlcd_url = \"https://www.mrlc.gov/geoserver/mrlc_download/NLCD_2019_Land_Cover_L48/wcs\"\n\n    # Step 2: Urban-specific EEMT modifications\n    print(\"\\\\n2. Calculating urban-modified EEMT...\")\n\n    # Urban heat island temperature adjustment\n    def calculate_urban_temperature_effect(land_cover, base_temperature):\n        \"\"\"Apply urban heat island temperature corrections\"\"\"\n\n        # Urban heat island intensity by land cover class\n        uhi_correction = {\n            'developed_high': +4.0,      # \u00b0C increase in dense urban\n            'developed_medium': +2.5,    # \u00b0C increase in suburban  \n            'developed_low': +1.0,       # \u00b0C increase in low density\n            'developed_open': +0.5,      # \u00b0C increase in parks/open space\n            'natural': 0.0               # No UHI effect\n        }\n\n        # Apply corrections based on land cover\n        temp_adjusted = base_temperature.copy()\n        for class_name, correction in uhi_correction.items():\n            mask = land_cover == class_name\n            temp_adjusted[mask] += correction\n\n        return temp_adjusted\n\n    # Urban albedo effects\n    def calculate_urban_albedo(land_cover):\n        \"\"\"Calculate albedo by urban land cover type\"\"\"\n\n        albedo_values = {\n            'developed_high': 0.15,     # Dark urban surfaces\n            'developed_medium': 0.18,   # Mixed urban/suburban\n            'developed_low': 0.22,      # Suburban with vegetation\n            'developed_open': 0.25,     # Parks and open space\n            'natural': 0.20             # Natural vegetation\n        }\n\n        albedo = np.zeros_like(land_cover, dtype=np.float32)\n        for class_name, albedo_val in albedo_values.items():\n            mask = land_cover == class_name\n            albedo[mask] = albedo_val\n\n        return albedo\n\n    # Urban NPP modifications\n    def calculate_urban_npp(land_cover, base_npp):\n        \"\"\"Modify NPP for urban land cover effects\"\"\"\n\n        npp_factors = {\n            'developed_high': 0.1,      # Very low NPP in dense urban\n            'developed_medium': 0.3,    # Reduced NPP in suburban\n            'developed_low': 0.6,       # Moderate NPP with some vegetation\n            'developed_open': 0.8,      # Near-natural NPP in parks\n            'natural': 1.0              # Unmodified NPP\n        }\n\n        npp_urban = base_npp.copy()\n        for class_name, factor in npp_factors.items():\n            mask = land_cover == class_name\n            npp_urban[mask] *= factor\n\n        return npp_urban\n\n    # Step 3: Run urban EEMT calculation\n    print(\"\\\\n3. Running urban EEMT calculation...\")\n\n    # Load base data\n    with rasterio.open(dem_file) as src:\n        elevation = src.read(1)\n        profile = src.profile\n\n    # Load land cover (placeholder - implement actual NLCD loading)\n    land_cover = np.random.choice(['developed_high', 'developed_medium', 'natural'], \n                                 size=elevation.shape)\n\n    # Load climate data\n    climate_data = load_daymet_annual_means(STUDY_AREA['bbox'], 2020)\n\n    # Apply urban modifications\n    temp_urban = calculate_urban_temperature_effect(land_cover, climate_data['temperature'])\n    albedo_urban = calculate_urban_albedo(land_cover) \n\n    # Calculate solar radiation with urban albedo\n    # (This would integrate with r.sun calculations)\n\n    # Calculate urban NPP\n    base_npp = calculate_npp_lieth(temp_urban, climate_data['precipitation'])\n    npp_urban = calculate_urban_npp(land_cover, base_npp)\n\n    # Calculate urban EEMT\n    h_bio = 22e6\n    c_w = 4180\n\n    e_bio = (npp_urban / 1000) * h_bio / (365 * 24 * 3600)\n    e_ppt = (climate_data['effective_precipitation'] / 1000) * c_w * np.maximum(0, temp_urban - 273.15) / (365 * 24 * 3600)\n\n    eemt_urban = (e_bio + e_ppt) * 365 * 24 * 3600 / 1e6\n\n    # Step 4: Urban vs natural comparison\n    print(\"\\\\n4. Comparing urban vs natural EEMT...\")\n\n    # Calculate natural EEMT (without urban effects)\n    temp_natural = climate_data['temperature']\n    npp_natural = calculate_npp_lieth(temp_natural, climate_data['precipitation'])\n\n    e_bio_natural = (npp_natural / 1000) * h_bio / (365 * 24 * 3600)\n    e_ppt_natural = (climate_data['effective_precipitation'] / 1000) * c_w * np.maximum(0, temp_natural - 273.15) / (365 * 24 * 3600)\n    eemt_natural = (e_bio_natural + e_ppt_natural) * 365 * 24 * 3600 / 1e6\n\n    # Calculate urban effect\n    urban_effect = eemt_urban - eemt_natural\n\n    # Analyze by land cover class\n    print(\"\\\\nUrban EEMT Effects by Land Cover:\")\n    print(\"-\" * 50)\n    print(f\"{'Land Cover':&lt;18} | {'Mean EEMT':&lt;10} | {'Urban Effect':&lt;12}\")\n    print(\"-\" * 50)\n\n    for class_name in ['developed_high', 'developed_medium', 'developed_low', 'natural']:\n        mask = land_cover == class_name\n        if np.sum(mask) &gt; 100:  # Sufficient pixels\n            mean_eemt = np.nanmean(eemt_urban[mask])\n            mean_effect = np.nanmean(urban_effect[mask])\n            print(f\"{class_name:&lt;18} | {mean_eemt:8.1f} | {mean_effect:+10.1f}\")\n\n    # Step 5: Save results\n    print(\"\\\\n5. Saving urban analysis results...\")\n\n    outputs = {\n        'eemt_urban.tif': eemt_urban,\n        'eemt_natural.tif': eemt_natural,\n        'urban_effect.tif': urban_effect,\n        'temperature_urban.tif': temp_urban,\n        'npp_urban.tif': npp_urban,\n        'land_cover.tif': land_cover.astype(np.int16)\n    }\n\n    for filename, data in outputs.items():\n        with rasterio.open(project_dir / filename, 'w', **profile) as dst:\n            dst.write(data.astype(np.float32), 1)\n\n    print(f\"\u2713 Urban heat island analysis completed\")\n    print(f\"Results saved to: {project_dir}\")\n\nif __name__ == '__main__':\n    urban_heat_island_example()\n</code></pre>"},{"location":"examples/#example-4-climate-change-scenarios","title":"Example 4: Climate Change Scenarios","text":""},{"location":"examples/#future-eemt-projections","title":"Future EEMT Projections","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nClimate Change EEMT Projections\nCalculate EEMT under future climate scenarios\n\"\"\"\n\ndef climate_change_scenarios_example():\n    \"\"\"\n    EEMT calculation for climate change scenarios\n    Using bias-corrected climate model projections\n    \"\"\"\n\n    SCENARIOS = {\n        'baseline': {\n            'period': [1980, 2010],\n            'description': 'Historical baseline'\n        },\n        'near_future': {\n            'period': [2020, 2050], \n            'temp_change': +2.0,  # \u00b0C warming\n            'precip_change': -10,  # % precipitation change\n            'description': 'Near-term projections'\n        },\n        'far_future': {\n            'period': [2070, 2100],\n            'temp_change': +4.0,  # \u00b0C warming  \n            'precip_change': -20,  # % precipitation change\n            'description': 'End-of-century projections'\n        }\n    }\n\n    project_dir = Path('climate_scenarios_eemt')\n    project_dir.mkdir(exist_ok=True)\n\n    print(\"=== Climate Change EEMT Scenarios ===\")\n\n    # Calculate EEMT for each scenario\n    scenario_results = {}\n\n    for scenario_name, scenario in SCENARIOS.items():\n\n        print(f\"\\\\nCalculating {scenario_name} scenario...\")\n        print(f\"  Description: {scenario['description']}\")\n\n        if scenario_name == 'baseline':\n            # Use historical data\n            eemt_result = calculate_historical_eemt(project_dir / scenario_name)\n        else:\n            # Apply climate change modifications\n            eemt_result = calculate_future_eemt(\n                project_dir / scenario_name,\n                temp_change=scenario['temp_change'],\n                precip_change=scenario['precip_change']\n            )\n\n        scenario_results[scenario_name] = eemt_result\n        print(f\"\u2713 {scenario_name} completed\")\n\n    # Compare scenarios\n    print(\"\\\\nClimate Change Impact Analysis:\")\n    print(\"-\" * 60)\n    print(f\"{'Scenario':&lt;15} | {'Mean EEMT':&lt;10} | {'Change from Baseline':&lt;18}\")\n    print(\"-\" * 60)\n\n    baseline_mean = np.nanmean(scenario_results['baseline'])\n\n    for scenario_name, result in scenario_results.items():\n        mean_eemt = np.nanmean(result)\n\n        if scenario_name == 'baseline':\n            change = 0.0\n            change_pct = 0.0\n        else:\n            change = mean_eemt - baseline_mean\n            change_pct = (change / baseline_mean) * 100\n\n        print(f\"{scenario_name:&lt;15} | {mean_eemt:8.1f} | {change:+8.1f} ({change_pct:+5.1f}%)\")\n\n    # Spatial analysis of changes\n    print(\"\\\\nSpatial Analysis of Climate Impacts:\")\n\n    for scenario_name in ['near_future', 'far_future']:\n        change_map = scenario_results[scenario_name] - scenario_results['baseline']\n\n        print(f\"\\\\n{scenario_name.replace('_', ' ').title()} Changes:\")\n        print(f\"  Mean change: {np.nanmean(change_map):+6.2f} MJ/m\u00b2/yr\")\n        print(f\"  Max increase: {np.nanmax(change_map):+6.2f} MJ/m\u00b2/yr\")\n        print(f\"  Max decrease: {np.nanmin(change_map):+6.2f} MJ/m\u00b2/yr\")\n\n        # Save change maps\n        change_file = project_dir / f'eemt_change_{scenario_name}.tif'\n        with rasterio.open(change_file, 'w', **profile) as dst:\n            dst.write(change_map.astype(np.float32), 1)\n\n    print(f\"\\\\n\u2713 Climate change analysis completed\")\n    print(f\"Results saved to: {project_dir}\")\n\nif __name__ == '__main__':\n    climate_change_scenarios_example()\n</code></pre>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":""},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<pre><code># Ensure all dependencies are installed\npip install -r requirements.txt\n\n# Verify GRASS GIS installation\ngrass --version\n\n# Check data access\npython -c \"import requests; print('\u2713 Internet connection OK')\"\n</code></pre>"},{"location":"examples/#example-execution","title":"Example Execution","text":"<pre><code># Run Arizona Sky Islands example\ncd docs/examples/\npython arizona_sky_islands.py\n\n# Run large watershed example  \npython large_watershed.py --max-workers 4\n\n# Run urban heat island example\npython urban_heat_island.py --resolution 1m\n\n# Run climate scenarios example\npython climate_scenarios.py --scenarios all\n</code></pre>"},{"location":"examples/#expected-results","title":"Expected Results","text":""},{"location":"examples/#arizona-sky-islands","title":"Arizona Sky Islands","text":"<ul> <li>EEMT Range: 5-45 MJ/m\u00b2/yr across elevation gradient</li> <li>Aspect Effect: ~5 MJ/m\u00b2/yr higher on north-facing slopes</li> <li>Elevation Effect: 300m elevation \u2248 north-facing aspect</li> </ul>"},{"location":"examples/#large-watershed","title":"Large Watershed","text":"<ul> <li>Processing Time: ~2-6 hours for Colorado River Basin</li> <li>Tile Success Rate: &gt;95% with robust error handling</li> <li>Spatial Patterns: Clear elevation and latitude gradients</li> </ul>"},{"location":"examples/#urban-heat-island","title":"Urban Heat Island","text":"<ul> <li>Urban Effect: +2-8 MJ/m\u00b2/yr in developed areas</li> <li>Land Cover Sensitivity: Strong correlation with development density</li> <li>Seasonal Variation: Greatest effects during summer months</li> </ul>"},{"location":"examples/#climate-scenarios","title":"Climate Scenarios","text":"<ul> <li>Temperature Sensitivity: ~2-4 MJ/m\u00b2/yr per \u00b0C warming</li> <li>Precipitation Sensitivity: Varies by baseline aridity</li> <li>Spatial Heterogeneity: Mountain regions most sensitive</li> </ul> <p>These examples demonstrate the flexibility and power of the EEMT framework for diverse earth system applications, from local ecosystem studies to continental-scale climate impact assessments.</p>"},{"location":"getting-started/","title":"Getting Started with EEMT","text":""},{"location":"getting-started/#overview","title":"Overview","text":"<p>This guide will help you set up the EEMT calculation environment and run your first analysis. EEMT calculations require topographic data, climate data, and specialized GIS software.</p>"},{"location":"getting-started/#system-requirements","title":"System Requirements","text":""},{"location":"getting-started/#minimum-hardware","title":"Minimum Hardware","text":"<ul> <li>CPU: 4 cores (8+ recommended for parallel processing)</li> <li>RAM: 8 GB (16+ GB recommended for large datasets)</li> <li>Storage: 50 GB free space (more for large study areas)</li> <li>GPU: Optional but recommended for r.sun calculations</li> </ul>"},{"location":"getting-started/#software-dependencies","title":"Software Dependencies","text":""},{"location":"getting-started/#core-gis-stack","title":"Core GIS Stack","text":"<pre><code># Ubuntu/Debian installation\nsudo apt update\nsudo apt install grass grass-dev gdal-bin python3-gdal python3-rasterio\n\n# macOS (via Homebrew)\nbrew install grass gdal python\n\n# Windows: Use OSGeo4W installer or Conda\nconda install -c conda-forge grass gdal rasterio\n</code></pre>"},{"location":"getting-started/#python-environment","title":"Python Environment","text":"<pre><code># Create virtual environment\npython3 -m venv eemt-env\nsource eemt-env/bin/activate  # Linux/macOS\n# eemt-env\\Scripts\\activate   # Windows\n\n# Install required packages\npip install -r requirements.txt\n</code></pre>"},{"location":"getting-started/#required-python-packages","title":"Required Python Packages","text":"<pre><code>numpy&gt;=1.24\npandas&gt;=2.0\nxarray&gt;=2024.1\nrasterio&gt;=1.3\ngeopandas&gt;=0.14\nmatplotlib&gt;=3.7\nscipy&gt;=1.11\nrequests&gt;=2.28\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#eemt-components","title":"EEMT Components","text":"<p>Effective Energy and Mass Transfer quantifies energy flux to the Critical Zone:</p> <pre><code>EEMT = E_BIO + E_PPT [MJ m\u207b\u00b2 yr\u207b\u00b9]\n</code></pre>"},{"location":"getting-started/#biological-energy-e_bio","title":"Biological Energy (E_BIO)","text":"<ul> <li>Energy from photosynthesis and primary production</li> <li>Calculated from Net Primary Production (NPP)</li> <li>Formula: <code>E_BIO = NPP \u00d7 22 MJ/kg</code></li> </ul>"},{"location":"getting-started/#precipitation-energy-e_ppt","title":"Precipitation Energy (E_PPT)","text":"<ul> <li>Thermal energy from effective precipitation</li> <li>Water available for subsurface processes</li> <li>Formula: <code>E_PPT = F \u00d7 c_w \u00d7 \u0394T</code></li> <li>F = effective precipitation flux [kg m\u207b\u00b2 s\u207b\u00b9]</li> <li>c_w = specific heat of water [4.18 \u00d7 10\u00b3 J kg\u207b\u00b9 K\u207b\u00b9]</li> <li>\u0394T = temperature difference from 273.15K</li> </ul>"},{"location":"getting-started/#calculation-approaches","title":"Calculation Approaches","text":""},{"location":"getting-started/#1-traditional-eemt-eemt_trad","title":"1. Traditional EEMT (EEMT_TRAD)","text":"<ul> <li>Uses simple climate averages</li> <li>No topographic or vegetation effects</li> <li>Good for regional comparisons</li> </ul>"},{"location":"getting-started/#2-topographic-eemt-eemt_topo","title":"2. Topographic EEMT (EEMT_TOPO)","text":"<ul> <li>Incorporates slope, aspect, and solar radiation</li> <li>Mass-conservative water redistribution</li> <li>Accounts for local microclimates</li> </ul>"},{"location":"getting-started/#3-vegetation-eemt-eemt_topo-veg","title":"3. Vegetation EEMT (EEMT_TOPO-VEG)","text":"<ul> <li>Adds vegetation structure effects</li> <li>Uses Leaf Area Index (LAI) and canopy height</li> <li>Most accurate for site-specific analyses</li> </ul>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":""},{"location":"getting-started/#step-1-prepare-input-data","title":"Step 1: Prepare Input Data","text":""},{"location":"getting-started/#digital-elevation-model-dem","title":"Digital Elevation Model (DEM)","text":"<pre><code># Download USGS 3DEP data (example for Arizona)\nwget \"https://cloud.sdsc.edu/v1/AUTH_opentopography/Raster/SRTMGL1/SRTMGL1_srtm.zip\"\n\n# Or use OpenTopography API\ncurl -X GET \"https://portal.opentopography.org/API/globaldem\" \\\n  -G -d \"demtype=SRTMGL1\" \\\n  -d \"south=32.0\" -d \"north=32.5\" \\\n  -d \"west=-111.0\" -d \"east=-110.5\" \\\n  -d \"outputFormat=GTiff\"\n</code></pre>"},{"location":"getting-started/#climate-data","title":"Climate Data","text":"<pre><code># DAYMET data (automated download in workflow)\n# Or manual download from ORNL DAAC\n# https://daymet.ornl.gov/\n</code></pre>"},{"location":"getting-started/#step-2-set-up-grass-gis-environment","title":"Step 2: Set Up GRASS GIS Environment","text":"<pre><code># Create new GRASS location from DEM\ngrass -c your_dem.tif ~/grassdata/eemt_project/PERMANENT\n\n# Verify projection\ng.proj -p\n\n# Set computational region  \ng.region raster=your_dem -p\n</code></pre>"},{"location":"getting-started/#step-3-run-solar-radiation-analysis","title":"Step 3: Run Solar Radiation Analysis","text":"<pre><code># Basic solar radiation for single day\nr.sun elevation=dem day=180 glob_rad=solar_jun29\n\n# Multi-day parallel processing\npython sol/run-workflow --step 15 --num_threads 4 your_dem.tif\n</code></pre>"},{"location":"getting-started/#step-4-calculate-eemt","title":"Step 4: Calculate EEMT","text":""},{"location":"getting-started/#simple-eemt-calculation","title":"Simple EEMT Calculation","text":"<pre><code>import numpy as np\nimport rasterio\n\n# Load required data\nwith rasterio.open('solar_annual.tif') as src:\n    solar_radiation = src.read(1)\n\nwith rasterio.open('precipitation.tif') as src:\n    precipitation = src.read(1)\n\nwith rasterio.open('temperature.tif') as src:\n    temperature = src.read(1)\n\n# Calculate NPP (simplified)\nnpp = 3000 * (1 - np.exp(1.315 - 0.119 * temperature))  # kg/m\u00b2/yr\nnpp[precipitation &lt;= 0] = 0  # No production without water\n\n# Calculate energy components\ne_bio = npp * 22e6 / (365 * 24 * 3600)  # Convert to W/m\u00b2\ne_ppt = precipitation * 4180 * (temperature - 273.15) / (365 * 24 * 3600)\ne_ppt[e_ppt &lt; 0] = 0  # No energy below freezing\n\n# Calculate EEMT\neemt = e_bio + e_ppt  # W/m\u00b2\neemt_annual = eemt * 365 * 24 * 3600 / 1e6  # MJ/m\u00b2/yr\n</code></pre>"},{"location":"getting-started/#using-the-eemt-workflow","title":"Using the EEMT Workflow","text":"<pre><code># Full EEMT calculation with topography\ncd eemt/\npython run-workflow --start-year 2015 --end-year 2020 \\\n  --step 15 --num_threads 8 \\\n  --output eemt_results/ \\\n  your_dem.tif\n</code></pre>"},{"location":"getting-started/#validation-and-quality-control","title":"Validation and Quality Control","text":""},{"location":"getting-started/#check-input-data-quality","title":"Check Input Data Quality","text":"<pre><code># Verify DEM characteristics\nimport rasterio\nwith rasterio.open('dem.tif') as src:\n    print(f\"Projection: {src.crs}\")\n    print(f\"Resolution: {src.res}\")\n    print(f\"Bounds: {src.bounds}\")\n    print(f\"Data type: {src.dtypes[0]}\")\n</code></pre>"},{"location":"getting-started/#validate-eemt-results","title":"Validate EEMT Results","text":"<pre><code># Check EEMT value ranges\neemt_stats = {\n    'min': np.nanmin(eemt_annual),\n    'max': np.nanmax(eemt_annual), \n    'mean': np.nanmean(eemt_annual),\n    'std': np.nanstd(eemt_annual)\n}\n\nprint(f\"EEMT range: {eemt_stats['min']:.1f} - {eemt_stats['max']:.1f} MJ/m\u00b2/yr\")\n\n# Expected ranges by climate zone:\n# Arid: 5-15 MJ/m\u00b2/yr\n# Semiarid: 15-25 MJ/m\u00b2/yr  \n# Humid: 25-50 MJ/m\u00b2/yr\n</code></pre>"},{"location":"getting-started/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"getting-started/#memory-issues","title":"Memory Issues","text":"<pre><code># Process large DEMs in tiles\ngdal_retile.py -ps 1000 1000 -targetDir tiles/ large_dem.tif\n\n# Or use chunked processing with Dask\nimport dask.array as da\ndem_chunked = da.from_array(dem, chunks=(1000, 1000))\n</code></pre>"},{"location":"getting-started/#projection-problems","title":"Projection Problems","text":"<pre><code># Reproject DEM to match climate data\ngdalwarp -t_srs EPSG:4326 input_dem.tif output_dem.tif\n\n# Check coordinate reference systems\ngdalinfo dem.tif | grep -i \"coordinate system\"\n</code></pre>"},{"location":"getting-started/#missing-climate-data","title":"Missing Climate Data","text":"<pre><code># Download DAYMET data programmatically\npython scripts/download_daymet.py --bbox -111.0,32.0,-110.5,32.5 \\\n  --years 2015-2020 --variables tmin,tmax,prcp\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Once you have basic EEMT calculations working:</p> <ol> <li>Data Sources Guide - Access higher resolution data</li> <li>GRASS GIS Tutorials - Advanced terrain analysis</li> <li>Workflow Examples - Real-world case studies</li> <li>API Reference - Function documentation</li> </ol>"},{"location":"getting-started/#performance-optimization","title":"Performance Optimization","text":""},{"location":"getting-started/#parallel-processing","title":"Parallel Processing","text":"<ul> <li>Use <code>--num_threads</code> parameter for CPU cores</li> <li>Enable GPU acceleration for r.sun when available  </li> <li>Process multiple years simultaneously</li> </ul>"},{"location":"getting-started/#memory-management","title":"Memory Management","text":"<ul> <li>Tile large datasets with <code>gdal_retile.py</code></li> <li>Use compressed GeoTIFF outputs (<code>-co COMPRESS=LZW</code>)</li> <li>Monitor memory usage with <code>htop</code> or Task Manager</li> </ul>"},{"location":"getting-started/#storage-optimization","title":"Storage Optimization","text":"<ul> <li>Use Cloud-Optimized GeoTIFF (COG) format</li> <li>Compress intermediate files</li> <li>Clean up temporary GRASS locations</li> </ul> <p>For detailed technical information, see the scientific background and API documentation.</p>"},{"location":"grass-gis/","title":"GRASS GIS for EEMT Calculations","text":""},{"location":"grass-gis/#overview","title":"Overview","text":"<p>GRASS GIS provides the core geospatial analysis capabilities for EEMT calculations, particularly the r.sun module for solar radiation modeling. This guide covers installation, configuration, and parallel processing techniques.</p>"},{"location":"grass-gis/#contents","title":"Contents","text":"<ol> <li>Installation and Setup</li> <li>r.sun Solar Radiation Modeling  </li> <li>Parallel Processing with r.sun.mp</li> <li>Terrain Analysis</li> <li>Batch Processing Workflows</li> <li>Performance Optimization</li> </ol>"},{"location":"grass-gis/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"grass-gis/#grass-gis-installation","title":"GRASS GIS Installation","text":""},{"location":"grass-gis/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install GRASS GIS 8.x\nsudo apt update\nsudo apt install software-properties-common\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt update\nsudo apt install grass grass-dev grass-doc\n\n# Verify installation\ngrass --version\n</code></pre>"},{"location":"grass-gis/#macos","title":"macOS","text":"<pre><code># Via Homebrew\nbrew install grass\n\n# Or download from: https://grass.osgeo.org/download/mac/\n</code></pre>"},{"location":"grass-gis/#windows","title":"Windows","text":"<pre><code># Download OSGeo4W installer\n# https://trac.osgeo.org/osgeo4w/\n\n# Or use conda\nconda install -c conda-forge grass\n</code></pre>"},{"location":"grass-gis/#creating-a-grass-location","title":"Creating a GRASS Location","text":""},{"location":"grass-gis/#from-dem-file","title":"From DEM File","text":"<pre><code># Create location from DEM projection\ngrass -c /path/to/your_dem.tif ~/grassdata/eemt_project/PERMANENT\n\n# Alternative: create location interactively  \ngrass ~/grassdata/eemt_project/PERMANENT\n</code></pre>"},{"location":"grass-gis/#verify-setup","title":"Verify Setup","text":"<pre><code># Check projection information\ng.proj -p\n\n# Set computational region to match DEM\ng.region raster=your_dem -p\n\n# Display basic info\nr.info your_dem\n</code></pre>"},{"location":"grass-gis/#rsun-solar-radiation-modeling","title":"r.sun Solar Radiation Modeling","text":""},{"location":"grass-gis/#basic-rsun-usage","title":"Basic r.sun Usage","text":"<pre><code># Import DEM\nr.in.gdal input=dem.tif output=elevation\n\n# Calculate slope and aspect  \nr.slope.aspect elevation=elevation slope=slope_deg aspect=aspect_deg\n\n# Basic solar radiation calculation\nr.sun elevation=elevation aspect=aspect_deg slope=slope_deg \\\n      day=180 glob_rad=solar_june29 insol_time=hours_june29\n\n# View results\nd.rast solar_june29\n</code></pre>"},{"location":"grass-gis/#advanced-rsun-parameters","title":"Advanced r.sun Parameters","text":""},{"location":"grass-gis/#temporal-settings","title":"Temporal Settings","text":"<pre><code># Single day calculation\nr.sun elevation=dem day=180 step=0.25 \\\n      glob_rad=global_rad insol_time=sunshine_hours\n\n# Multi-day calculation\nr.sun elevation=dem start_day=170 end_day=190 day_step=1 \\\n      step=0.25 glob_rad=summer_radiation\n</code></pre>"},{"location":"grass-gis/#atmospheric-parameters","title":"Atmospheric Parameters","text":"<pre><code># Atmospheric conditions\nr.sun elevation=dem day=180 \\\n      linke_value=3.0 \\        # Atmospheric turbidity (1.0-8.0)\n      albedo_value=0.2 \\       # Surface albedo (0.0-1.0)  \n      slope_value=0.1 \\        # Solar constant correction\n      aspect_value=180.0 \\     # Default south-facing slope\n      glob_rad=solar_output insol_time=sun_hours\n</code></pre>"},{"location":"grass-gis/#horizon-and-shading","title":"Horizon and Shading","text":"<pre><code># Include horizon effects  \nr.sun elevation=dem day=180 \\\n      horizonstep=30 \\         # Horizon calculation step (degrees)\n      horizon=horizon_angles \\  # Output horizon file\n      glob_rad=solar_with_horizon\n\n# Cast shadows from features\nr.sun elevation=dem day=180 \\\n      cast_shadow=shadow_map \\  # Shadow raster output\n      glob_rad=solar_with_shadows\n</code></pre>"},{"location":"grass-gis/#parallel-processing-with-rsunmp","title":"Parallel Processing with r.sun.mp","text":""},{"location":"grass-gis/#openmp-multi-core-processing","title":"OpenMP Multi-core Processing","text":"<pre><code># Set number of threads\nexport OMP_NUM_THREADS=8\n\n# Run r.sun with multiple threads\nr.sun.mp elevation=dem aspect=aspect_deg slope=slope_deg \\\n         day=180 step=0.25 threads=8 \\\n         glob_rad=solar_parallel insol_time=hours_parallel\n</code></pre>"},{"location":"grass-gis/#python-wrapper-for-parallel-processing","title":"Python Wrapper for Parallel Processing","text":"<p>Based on the analysis of <code>/sol/rsun.sh</code>, here's the enhanced parallel processing approach:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nEnhanced r.sun parallel processing for EEMT calculations\nBased on sol/run-workflow with modern improvements\n\"\"\"\n\nimport os\nimport sys\nimport argparse\nimport multiprocessing as mp\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nimport subprocess\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\nclass GrassSolarCalculator:\n    \"\"\"GRASS GIS solar radiation calculator with parallel processing\"\"\"\n\n    def __init__(self, dem_path, output_dir, num_threads=None):\n        self.dem_path = Path(dem_path)\n        self.output_dir = Path(output_dir)\n        self.num_threads = num_threads or mp.cpu_count()\n\n        # Create output directories\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        (self.output_dir / 'global' / 'daily').mkdir(parents=True, exist_ok=True)\n        (self.output_dir / 'insol' / 'daily').mkdir(parents=True, exist_ok=True)\n\n    def setup_grass_environment(self, day):\n        \"\"\"Create temporary GRASS environment for single day calculation\"\"\"\n\n        # Create temporary directory\n        temp_dir = tempfile.mkdtemp(prefix=f'grass_day_{day}_')\n        location_dir = Path(temp_dir) / 'grassdata' / f'solar_day_{day}' / 'PERMANENT'\n        location_dir.mkdir(parents=True, exist_ok=True)\n\n        # GRASS environment variables\n        grass_env = os.environ.copy()\n        grass_env.update({\n            'GISDBASE': str(location_dir.parent.parent),\n            'LOCATION_NAME': f'solar_day_{day}',\n            'MAPSET': 'PERMANENT',\n            'GRASS_GUI': 'text',\n            'GRASS_VERBOSE': '0'\n        })\n\n        return temp_dir, grass_env\n\n    def calculate_daily_solar(self, day, step=0.25, linke_value=3.0, albedo_value=0.2):\n        \"\"\"Calculate solar radiation for a single day\"\"\"\n\n        temp_dir, grass_env = self.setup_grass_environment(day)\n\n        try:\n            # Start GRASS session\n            grass_cmd = [\n                'grass', '--text',\n                f\"{grass_env['GISDBASE']}/{grass_env['LOCATION_NAME']}/{grass_env['MAPSET']}\"\n            ]\n\n            # GRASS commands\n            commands = f\"\"\"\n# Create location from DEM\ng.proj -c georef={self.dem_path}\n\n# Import DEM\nr.in.gdal input={self.dem_path} output=dem\n\n# Set region\ng.region raster=dem\n\n# Calculate slope and aspect  \nr.slope.aspect elevation=dem slope=slope_deg aspect=aspect_deg\n\n# Run r.sun.mp with optimal threading\nr.sun.mp elevation=dem aspect=aspect_deg slope=slope_deg \\\\\n         day={day} step={step} \\\\\n         linke_value={linke_value} albedo_value={albedo_value} \\\\\n         threads={min(self.num_threads, 4)} \\\\\n         glob_rad=solar_global insol_time=solar_hours\n\n# Export results\nr.out.gdal input=solar_global output={self.output_dir}/global/daily/total_sun_day_{day}.tif \\\\\n           createopt=\"COMPRESS=LZW,TILED=YES\"\n\nr.out.gdal input=solar_hours output={self.output_dir}/insol/daily/hours_sun_day_{day}.tif \\\\\n           createopt=\"COMPRESS=LZW,TILED=YES\"\n\"\"\"\n\n            # Execute GRASS commands\n            process = subprocess.Popen(\n                grass_cmd,\n                stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                env=grass_env\n            )\n\n            stdout, stderr = process.communicate(input=commands)\n\n            if process.returncode != 0:\n                raise RuntimeError(f\"GRASS error for day {day}: {stderr}\")\n\n            print(f\"Completed day {day}\")\n            return day\n\n        finally:\n            # Cleanup temporary directory\n            shutil.rmtree(temp_dir, ignore_errors=True)\n\n    def calculate_annual_solar(self, year_days=None, step=0.25, linke_value=3.0, albedo_value=0.2):\n        \"\"\"Calculate solar radiation for multiple days in parallel\"\"\"\n\n        if year_days is None:\n            year_days = range(1, 366)  # Full year\n\n        print(f\"Calculating solar radiation for {len(year_days)} days using {self.num_threads} threads\")\n\n        # Process days in parallel\n        with ProcessPoolExecutor(max_workers=self.num_threads) as executor:\n\n            # Submit all tasks\n            future_to_day = {\n                executor.submit(\n                    self.calculate_daily_solar, \n                    day, step, linke_value, albedo_value\n                ): day for day in year_days\n            }\n\n            # Collect results\n            completed_days = []\n            for future in as_completed(future_to_day):\n                day = future_to_day[future]\n                try:\n                    result = future.result()\n                    completed_days.append(result)\n                    print(f\"\u2713 Day {day} completed ({len(completed_days)}/{len(year_days)})\")\n                except Exception as e:\n                    print(f\"\u2717 Day {day} failed: {e}\")\n\n        return completed_days\n\n    def calculate_monthly_summaries(self):\n        \"\"\"Calculate monthly summaries from daily outputs\"\"\"\n\n        months = {\n            'jan': range(1, 32),   'feb': range(32, 60),   'mar': range(60, 91),\n            'apr': range(91, 121), 'may': range(121, 152), 'jun': range(152, 182),\n            'jul': range(182, 213), 'aug': range(213, 244), 'sep': range(244, 274),\n            'oct': range(274, 305), 'nov': range(305, 335), 'dec': range(335, 366)\n        }\n\n        for month, days in months.items():\n\n            # Build list of daily files\n            global_files = [f\"{self.output_dir}/global/daily/total_sun_day_{day}.tif\" \n                          for day in days]\n            insol_files = [f\"{self.output_dir}/insol/daily/hours_sun_day_{day}.tif\" \n                         for day in days]\n\n            # Check if all daily files exist\n            missing_files = [f for f in global_files + insol_files if not os.path.exists(f)]\n            if missing_files:\n                print(f\"Warning: Missing files for {month}: {len(missing_files)} files\")\n                continue\n\n            # Calculate monthly sums using GDAL\n            global_output = f\"{self.output_dir}/global/monthly/total_sun_{month}_sum.tif\"\n            insol_output = f\"{self.output_dir}/insol/monthly/hours_sun_{month}_sum.tif\"\n\n            # Sum global radiation\n            global_vrt = f\"/tmp/global_{month}.vrt\"\n            subprocess.run([\n                'gdalbuildvrt', '-separate', global_vrt\n            ] + global_files, check=True)\n\n            subprocess.run([\n                'gdal_calc.py', '-A', global_vrt, '--calc=sum(A,axis=0)',\n                '--outfile', global_output, '--co', 'COMPRESS=LZW'\n            ], check=True)\n\n            # Sum insolation hours  \n            insol_vrt = f\"/tmp/insol_{month}.vrt\"\n            subprocess.run([\n                'gdalbuildvrt', '-separate', insol_vrt\n            ] + insol_files, check=True)\n\n            subprocess.run([\n                'gdal_calc.py', '-A', insol_vrt, '--calc=sum(A,axis=0)', \n                '--outfile', insol_output, '--co', 'COMPRESS=LZW'\n            ], check=True)\n\n            print(f\"\u2713 {month} monthly summary completed\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='EEMT Solar Radiation Calculator')\n    parser.add_argument('dem', help='Input DEM file path')\n    parser.add_argument('--output', '-o', default='./solar_output', \n                       help='Output directory')\n    parser.add_argument('--threads', '-t', type=int, default=mp.cpu_count(),\n                       help='Number of parallel threads')\n    parser.add_argument('--step', type=float, default=0.25,\n                       help='Solar calculation time step (hours)')\n    parser.add_argument('--linke', type=float, default=3.0,\n                       help='Linke atmospheric turbidity factor')\n    parser.add_argument('--albedo', type=float, default=0.2,\n                       help='Surface albedo value')\n    parser.add_argument('--days', nargs='+', type=int,\n                       help='Specific days to calculate (default: full year)')\n\n    args = parser.parse_args()\n\n    # Initialize calculator\n    calculator = GrassSolarCalculator(\n        args.dem, \n        args.output, \n        args.threads\n    )\n\n    # Calculate solar radiation\n    days = args.days if args.days else range(1, 366)\n    completed = calculator.calculate_annual_solar(\n        days, args.step, args.linke, args.albedo\n    )\n\n    # Calculate monthly summaries\n    if len(completed) &gt;= 300:  # Most of year calculated\n        calculator.calculate_monthly_summaries()\n\n    print(f\"Solar radiation calculation complete!\")\n    print(f\"Output directory: {args.output}\")\n    print(f\"Completed days: {len(completed)}\")\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"grass-gis/#optimized-rsunmp-usage","title":"Optimized r.sun.mp Usage","text":""},{"location":"grass-gis/#memory-management","title":"Memory Management","text":"<pre><code># For large DEMs, set memory limits\nexport GRASS_VECTOR_TMPDIR_MAPSET=/tmp\nexport GRASS_RASTER_TMPDIR_MAPSET=/tmp\n\n# Increase cache size\ng.gisenv set=\"GRASS_CACHE_SIZE=2048\"\n</code></pre>"},{"location":"grass-gis/#multi-core-configuration","title":"Multi-core Configuration","text":"<pre><code># Optimize for system architecture\nexport OMP_NUM_THREADS=$(nproc)\nexport GRASS_NUM_THREADS=$(nproc)\n\n# NUMA-aware processing (large systems)\nnumactl --cpunodebind=0 --membind=0 r.sun.mp elevation=dem ...\n</code></pre>"},{"location":"grass-gis/#high-performance-rsun-workflow","title":"High-Performance r.sun Workflow","text":"<p>Based on the <code>/sol/rsun.sh</code> analysis, here's the optimized workflow:</p> <pre><code>#!/bin/bash\n# High-performance solar radiation calculation\n# Enhanced version of sol/rsun.sh\n\nset -e\n\n# Parse command line arguments\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    -d|--day)\n      DAY=\"$2\"\n      shift 2\n      ;;\n    -s|--step)  \n      STEP=\"$2\"\n      shift 2\n      ;;\n    -t|--threads)\n      NUM_THREADS=\"$2\"\n      shift 2\n      ;;\n    -l|--linke)\n      LINKE_VALUE=\"$2\"\n      shift 2\n      ;;\n    -a|--albedo)\n      ALBEDO_VALUE=\"$2\"\n      shift 2\n      ;;\n    -o|--output)\n      OUTPUT_DIR=\"$2\"\n      shift 2\n      ;;\n    *)\n      DEM_FILE=\"$1\"\n      shift\n      ;;\n  esac\ndone\n\n# Set defaults\nNUM_THREADS=${NUM_THREADS:-$(nproc)}\nSTEP=${STEP:-0.25}\nLINKE_VALUE=${LINKE_VALUE:-3.0}\nALBEDO_VALUE=${ALBEDO_VALUE:-0.2}\nOUTPUT_DIR=${OUTPUT_DIR:-\"./solar_output\"}\n\n# Validate inputs\nif [[ ! -f \"$DEM_FILE\" ]]; then\n    echo \"Error: DEM file not found: $DEM_FILE\"\n    exit 1\nfi\n\n# Create temporary GRASS location\nTEMP_LOCATION=$(mktemp -d)\nGRASS_LOCATION=\"$TEMP_LOCATION/solar_calc\"\n\n# Setup GRASS environment\nexport GISDBASE=\"$TEMP_LOCATION\"\nexport LOCATION_NAME=\"solar_calc\"\nexport MAPSET=\"PERMANENT\"\nexport GRASS_GUI=\"text\"\nexport GRASS_VERBOSE=0\n\necho \"Starting solar calculation for day $DAY\"\necho \"Threads: $NUM_THREADS, Step: ${STEP}h, Linke: $LINKE_VALUE, Albedo: $ALBEDO_VALUE\"\n\n# Create output directories\nmkdir -p \"$OUTPUT_DIR/global/daily\"\nmkdir -p \"$OUTPUT_DIR/insol/daily\"\n\n# Run GRASS commands\ngrass --text \"$GRASS_LOCATION\" --exec &lt;&lt; EOF\n# Create location from DEM\ng.proj -c georef=$DEM_FILE\n\n# Import DEM\nr.in.gdal input=$DEM_FILE output=dem\n\n# Set computational region\ng.region raster=dem\n\n# Calculate terrain derivatives\necho \"Calculating slope and aspect...\"\nr.slope.aspect elevation=dem slope=slope_deg aspect=aspect_deg\n\n# Calculate solar radiation with optimal threading\necho \"Running r.sun.mp for day $DAY...\"\nr.sun.mp elevation=dem aspect=aspect_deg slope=slope_deg \\\\\n         day=$DAY step=$STEP \\\\\n         linke_value=$LINKE_VALUE albedo_value=$ALBEDO_VALUE \\\\\n         threads=$NUM_THREADS \\\\\n         glob_rad=solar_global insol_time=solar_hours\n\n# Export results with compression\necho \"Exporting results...\"\nr.out.gdal input=solar_global \\\\\n           output=$OUTPUT_DIR/global/daily/total_sun_day_$DAY.tif \\\\\n           createopt=\"COMPRESS=LZW,TILED=YES,BLOCKXSIZE=512,BLOCKYSIZE=512\"\n\nr.out.gdal input=solar_hours \\\\\n           output=$OUTPUT_DIR/insol/daily/hours_sun_day_$DAY.tif \\\\\n           createopt=\"COMPRESS=LZW,TILED=YES,BLOCKXSIZE=512,BLOCKYSIZE=512\"\n\necho \"Day $DAY completed successfully\"\nEOF\n\n# Cleanup\nrm -rf \"$TEMP_LOCATION\"\n\necho \"Solar calculation for day $DAY finished\"\n</code></pre>"},{"location":"grass-gis/#batch-processing-all-days","title":"Batch Processing All Days","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nBatch process full year of solar radiation calculations\nEnhanced version of sol/run-workflow\n\"\"\"\n\nimport subprocess\nimport multiprocessing as mp\nfrom concurrent.futures import ProcessPoolExecutor\nimport argparse\nfrom pathlib import Path\n\ndef run_daily_solar(day, dem_file, output_dir, step, linke, albedo, threads_per_day):\n    \"\"\"Run solar calculation for single day\"\"\"\n\n    cmd = [\n        'bash', 'enhanced_rsun.sh',\n        '--day', str(day),\n        '--step', str(step),\n        '--linke', str(linke),\n        '--albedo', str(albedo),  \n        '--threads', str(threads_per_day),\n        '--output', output_dir,\n        dem_file\n    ]\n\n    try:\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)\n        if result.returncode == 0:\n            return day, True, None\n        else:\n            return day, False, result.stderr\n    except subprocess.TimeoutExpired:\n        return day, False, \"Timeout after 1 hour\"\n    except Exception as e:\n        return day, False, str(e)\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('dem', help='Input DEM file')\n    parser.add_argument('--output', '-o', default='./solar_annual', help='Output directory')\n    parser.add_argument('--workers', '-w', type=int, default=mp.cpu_count()//4, \n                       help='Number of parallel day processes')\n    parser.add_argument('--threads-per-day', '-t', type=int, default=4,\n                       help='Threads per daily calculation')\n    parser.add_argument('--step', type=float, default=0.25, help='Time step (hours)')\n    parser.add_argument('--linke', type=float, default=3.0, help='Linke turbidity')  \n    parser.add_argument('--albedo', type=float, default=0.2, help='Surface albedo')\n    parser.add_argument('--start-day', type=int, default=1, help='Start day of year')\n    parser.add_argument('--end-day', type=int, default=365, help='End day of year')\n\n    args = parser.parse_args()\n\n    # Create output directory\n    Path(args.output).mkdir(parents=True, exist_ok=True)\n\n    # Days to process\n    days = range(args.start_day, args.end_day + 1)\n\n    print(f\"Processing {len(days)} days using {args.workers} parallel workers\")\n    print(f\"Each day uses {args.threads_per_day} threads\")\n    print(f\"Total system load: {args.workers * args.threads_per_day} threads\")\n\n    # Process days in parallel\n    completed = []\n    failed = []\n\n    with ProcessPoolExecutor(max_workers=args.workers) as executor:\n\n        # Submit all day calculations\n        future_to_day = {\n            executor.submit(\n                run_daily_solar,\n                day, args.dem, args.output, \n                args.step, args.linke, args.albedo, args.threads_per_day\n            ): day for day in days\n        }\n\n        # Collect results\n        for future in future_to_day:\n            day, success, error = future.result()\n\n            if success:\n                completed.append(day)\n                print(f\"\u2713 Day {day} ({len(completed)}/{len(days)})\")\n            else:\n                failed.append((day, error))\n                print(f\"\u2717 Day {day} failed: {error}\")\n\n    # Summary\n    print(f\"\\nCompleted: {len(completed)} days\")\n    print(f\"Failed: {len(failed)} days\")\n\n    if failed:\n        print(\"\\nFailed days:\")\n        for day, error in failed:\n            print(f\"  Day {day}: {error}\")\n\n    return len(completed) &gt; 0\n\nif __name__ == '__main__':\n    success = main()\n    sys.exit(0 if success else 1)\n</code></pre>"},{"location":"grass-gis/#gpu-acceleration-grass-8x","title":"GPU Acceleration (GRASS 8.x)","text":""},{"location":"grass-gis/#opencl-setup-for-rsun","title":"OpenCL Setup for r.sun","text":"<pre><code># Check OpenCL availability\ngrass --text &lt;&lt; EOF\nr.sun.mp --help | grep -i opencl\nEOF\n\n# Enable GPU acceleration (if available)\ngrass --text &lt;&lt; EOF\n# Set OpenCL device\ng.gisenv set=\"GRASS_OPENCL_DEVICE=0\"\n\n# Run r.sun with GPU acceleration  \nr.sun.mp elevation=dem aspect=aspect slope=slope \\\\\n         day=180 step=0.1 opencl=yes \\\\\n         glob_rad=solar_gpu insol_time=hours_gpu\nEOF\n</code></pre>"},{"location":"grass-gis/#memory-optimization-for-large-dems","title":"Memory Optimization for Large DEMs","text":""},{"location":"grass-gis/#tiled-processing","title":"Tiled Processing","text":"<pre><code># Split large DEM into manageable tiles\ngdal_retile.py -ps 2048 2048 -overlap 128 \\\\\n               -targetDir dem_tiles/ large_dem.tif\n\n# Process each tile separately\nfor tile in dem_tiles/*.tif; do\n    echo \"Processing $tile...\"\n    python enhanced_solar_calc.py \"$tile\" --output \"results_$(basename $tile .tif)\"\ndone\n\n# Merge results\ngdal_merge.py -o final_solar.tif results_*/global/monthly/*.tif\n</code></pre>"},{"location":"grass-gis/#chunked-processing-with-grass","title":"Chunked Processing with GRASS","text":"<pre><code>def process_dem_chunks(dem_path, chunk_size=2048, overlap=128):\n    \"\"\"Process large DEM in chunks\"\"\"\n\n    import rasterio\n    from rasterio.windows import Window\n\n    with rasterio.open(dem_path) as src:\n        height, width = src.shape\n\n        # Calculate chunk coordinates\n        chunks = []\n        for row in range(0, height, chunk_size - overlap):\n            for col in range(0, width, chunk_size - overlap):\n\n                # Define window\n                window = Window(\n                    col, row,\n                    min(chunk_size, width - col),\n                    min(chunk_size, height - row)\n                )\n\n                chunks.append(window)\n\n        print(f\"Processing {len(chunks)} chunks\")\n\n        # Process each chunk\n        for i, window in enumerate(chunks):\n\n            # Extract chunk\n            chunk_data = src.read(1, window=window)\n            chunk_transform = src.window_transform(window)\n\n            # Save chunk as temporary file\n            chunk_profile = src.profile.copy()\n            chunk_profile.update({\n                'height': window.height,\n                'width': window.width,\n                'transform': chunk_transform\n            })\n\n            chunk_file = f'chunk_{i}.tif'\n            with rasterio.open(chunk_file, 'w', **chunk_profile) as dst:\n                dst.write(chunk_data, 1)\n\n            # Process chunk with solar calculator\n            calculator = GrassSolarCalculator(chunk_file, f'chunk_output_{i}')\n            calculator.calculate_annual_solar()\n\n            # Cleanup chunk file\n            os.remove(chunk_file)\n</code></pre>"},{"location":"grass-gis/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"grass-gis/#resource-usage-tracking","title":"Resource Usage Tracking","text":"<pre><code>import psutil\nimport time\nfrom functools import wraps\n\ndef monitor_performance(func):\n    \"\"\"Decorator to monitor CPU and memory usage\"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n\n        # Initial measurements\n        start_time = time.time()\n        process = psutil.Process()\n        start_cpu = process.cpu_percent()\n        start_memory = process.memory_info().rss / 1024**2  # MB\n\n        try:\n            # Run function\n            result = func(*args, **kwargs)\n\n            # Final measurements\n            end_time = time.time()\n            end_cpu = process.cpu_percent()\n            end_memory = process.memory_info().rss / 1024**2\n\n            # Print performance stats\n            duration = end_time - start_time\n            print(f\"\\nPerformance Summary:\")\n            print(f\"  Duration: {duration:.1f} seconds\")\n            print(f\"  CPU usage: {end_cpu:.1f}%\")\n            print(f\"  Memory usage: {end_memory:.1f} MB\")\n            print(f\"  Memory change: {end_memory - start_memory:+.1f} MB\")\n\n            return result\n\n        except Exception as e:\n            print(f\"Error during execution: {e}\")\n            raise\n\n    return wrapper\n\n# Apply to solar calculations\n@monitor_performance\ndef calculate_solar_monitored(day, dem_file, output_dir):\n    \"\"\"Solar calculation with performance monitoring\"\"\"\n    calculator = GrassSolarCalculator(dem_file, output_dir)\n    return calculator.calculate_daily_solar(day)\n</code></pre>"},{"location":"grass-gis/#advanced-grass-configuration","title":"Advanced GRASS Configuration","text":""},{"location":"grass-gis/#parallel-processing-environment","title":"Parallel Processing Environment","text":"<pre><code># ~/.bashrc configuration for GRASS parallel processing\nexport GRASS_NUM_THREADS=$(nproc)\nexport OMP_NUM_THREADS=$(nproc)\nexport GRASS_CACHE_SIZE=2048\nexport GRASS_RENDER_IMMEDIATE=FALSE\nexport GRASS_COMPRESS_NULLS=1\n\n# For HPC environments\nexport GRASS_BATCH_JOB=TRUE\nexport GRASS_GUI=text\nexport GRASS_VERBOSE=0\n</code></pre>"},{"location":"grass-gis/#clusterhpc-integration","title":"Cluster/HPC Integration","text":"<pre><code>#!/bin/bash\n#SBATCH --job-name=eemt_solar\n#SBATCH --nodes=1\n#SBATCH --ntasks-per-node=1\n#SBATCH --cpus-per-task=24\n#SBATCH --memory=64GB\n#SBATCH --time=12:00:00\n\n# Load modules\nmodule load grass/8.3 gdal/3.6 python/3.11\n\n# Set GRASS environment\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\nexport GRASS_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n# Run solar calculations\npython enhanced_solar_calc.py $DEM_FILE \\\\\n  --threads $SLURM_CPUS_PER_TASK \\\\\n  --output $SLURM_SUBMIT_DIR/solar_results\n</code></pre>"},{"location":"grass-gis/#troubleshooting","title":"Troubleshooting","text":""},{"location":"grass-gis/#common-issues","title":"Common Issues","text":""},{"location":"grass-gis/#memory-errors","title":"Memory Errors","text":"<pre><code># Reduce processing extent\ng.region -s res=30  # Decrease resolution temporarily\n\n# Use tiled processing\nr.tile input=large_dem output=dem_tile prefix=chunk_ width=2048 height=2048\n</code></pre>"},{"location":"grass-gis/#projection-issues","title":"Projection Issues","text":"<pre><code># Check DEM projection\ngdalinfo dem.tif | grep -i \"coordinate system\"\n\n# Reproject if needed\ngdalwarp -t_srs EPSG:4326 input_dem.tif output_dem_wgs84.tif\n</code></pre>"},{"location":"grass-gis/#rsun-errors","title":"r.sun Errors","text":"<pre><code># Validate slope/aspect values\nr.info slope_deg\nr.info aspect_deg\n\n# Check for null values\nr.null setnull=\"-9999\" slope_deg\n</code></pre> <p>Next: Complete EEMT Workflows</p>"},{"location":"workflows/","title":"EEMT Calculation Workflows","text":""},{"location":"workflows/#overview","title":"Overview","text":"<p>This guide provides complete workflows for calculating EEMT using the three methodological approaches identified in Rasmussen et al. (2014):</p> <ol> <li>EEMT_TRAD: Traditional approach using climate averages</li> <li>EEMT_TOPO: Topographic controls on energy and water balance  </li> <li>EEMT_TOPO-VEG: Full vegetation and topographic integration</li> </ol>"},{"location":"workflows/#complete-eemt-calculation-framework","title":"Complete EEMT Calculation Framework","text":""},{"location":"workflows/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>Based on Rasmussen et al. (2014), EEMT is calculated as:</p> <pre><code>EEMT = E_BIO + E_PPT [MJ m\u207b\u00b2 yr\u207b\u00b9]\n</code></pre>"},{"location":"workflows/#biological-energy-component-e_bio","title":"Biological Energy Component (E_BIO)","text":"<p><pre><code>E_BIO = NPP \u00d7 h_BIO [W m\u207b\u00b2]\n</code></pre> Where: - NPP = Net Primary Production [kg m\u207b\u00b2 s\u207b\u00b9] - h_BIO = Specific biomass enthalpy (22 \u00d7 10\u2076 J kg\u207b\u00b9)</p>"},{"location":"workflows/#precipitation-energy-component-e_ppt","title":"Precipitation Energy Component (E_PPT)","text":"<p><pre><code>E_PPT = F \u00d7 c_w \u00d7 \u0394T [W m\u207b\u00b2]\n</code></pre> Where: - F = Effective precipitation flux [kg m\u207b\u00b2 s\u207b\u00b9] - c_w = Specific heat of water (4.18 \u00d7 10\u00b3 J kg\u207b\u00b9 K\u207b\u00b9) - \u0394T = T_ambient - 273.15K [K]</p>"},{"location":"workflows/#workflow-1-traditional-eemt-eemt_trad","title":"Workflow 1: Traditional EEMT (EEMT_TRAD)","text":""},{"location":"workflows/#overview_1","title":"Overview","text":"<p>Simple climate-based approach suitable for regional comparisons.</p>"},{"location":"workflows/#required-data","title":"Required Data","text":"<ul> <li>Monthly temperature (min/max)</li> <li>Monthly precipitation  </li> <li>Digital elevation model (for area calculation)</li> </ul>"},{"location":"workflows/#implementation","title":"Implementation","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nTraditional EEMT Calculation\nBased on Rasmussen et al. (2005, 2014)\n\"\"\"\n\nimport numpy as np\nimport rasterio\nimport pandas as pd\nfrom datetime import datetime\n\ndef calculate_pet_hamon(temp_mean, temp_max, temp_min, daylight_hours):\n    \"\"\"\n    Calculate potential evapotranspiration using Hamon's equation\n\n    Parameters:\n    temp_mean: mean monthly temperature [\u00b0C]\n    temp_max, temp_min: daily temperature extremes [\u00b0C]\n    daylight_hours: day length [hours]\n\n    Returns:\n    PET in mm/month\n    \"\"\"\n\n    # Saturated vapor pressure (Tetens equation)\n    es = 0.6108 * np.exp(17.27 * temp_mean / (temp_mean + 237.3))  # kPa\n\n    # Hamon PET equation\n    pet_daily = 0.55 * (daylight_hours / 12) * (es / (temp_mean + 273.15)) * 25.4\n\n    # Convert to monthly (approximate)\n    days_in_month = 30.4  # Average\n    pet_monthly = pet_daily * days_in_month\n\n    return pet_monthly\n\ndef calculate_npp_lieth(temperature, precipitation, pet):\n    \"\"\"\n    Calculate NPP using Lieth (1975) temperature-based approach\n\n    Parameters:\n    temperature: mean monthly temperature [\u00b0C]\n    precipitation: monthly precipitation [mm]\n    pet: potential evapotranspiration [mm]\n\n    Returns:\n    NPP in kg/m\u00b2/yr\n    \"\"\"\n\n    # Only calculate NPP for months with water surplus\n    npp_monthly = np.zeros_like(temperature)\n\n    for i, (temp, precip, evap) in enumerate(zip(temperature, precipitation, pet)):\n        if precip &gt; evap and temp &gt; 0:  # Growing conditions\n            # Lieth equation: NPP = 3000[1 - exp(1.315 - 0.119T)]^-1\n            npp_monthly[i] = 3000 * (1 - np.exp(1.315 - 0.119 * temp))**(-1)\n            npp_monthly[i] *= (precip - evap) / precip  # Scale by water availability\n        else:\n            npp_monthly[i] = 0\n\n    # Convert g/m\u00b2/month to kg/m\u00b2/yr  \n    npp_annual = np.sum(npp_monthly) / 1000  # g to kg conversion\n\n    return npp_annual\n\ndef calculate_eemt_traditional(temperature_data, precipitation_data, daylight_data):\n    \"\"\"\n    Calculate traditional EEMT for each pixel\n\n    Parameters:\n    temperature_data: dict with 'tmin', 'tmax', 'tmean' monthly arrays\n    precipitation_data: monthly precipitation array [mm]\n    daylight_data: monthly daylight hours array [hours]\n\n    Returns:\n    EEMT array in MJ/m\u00b2/yr\n    \"\"\"\n\n    # Get array dimensions\n    shape = temperature_data['tmean'].shape\n    eemt_result = np.zeros(shape)\n\n    # Process each pixel\n    for i in range(shape[0]):\n        for j in range(shape[1]):\n\n            # Extract pixel time series\n            temp_mean = temperature_data['tmean'][i, j, :]\n            temp_max = temperature_data['tmax'][i, j, :]\n            temp_min = temperature_data['tmin'][i, j, :]\n            precip = precipitation_data[i, j, :]\n            daylight = daylight_data[i, j, :]\n\n            # Skip if any data is missing\n            if np.any(np.isnan([temp_mean, precip])):\n                eemt_result[i, j] = np.nan\n                continue\n\n            # Calculate PET\n            pet = calculate_pet_hamon(temp_mean, temp_max, temp_min, daylight)\n\n            # Calculate effective precipitation (F)\n            effective_precip = np.maximum(0, precip - pet)  # mm/month\n\n            # Convert to mass flux [kg/m\u00b2/s]\n            seconds_per_month = 30.4 * 24 * 3600\n            F = (effective_precip / 1000) / seconds_per_month  # kg/m\u00b2/s\n\n            # Calculate E_PPT [W/m\u00b2]\n            c_w = 4180  # J/kg/K\n            delta_T = np.maximum(0, temp_mean - 0)  # \u00b0C above freezing\n            E_PPT = F * c_w * delta_T\n\n            # Calculate NPP\n            npp_annual = calculate_npp_lieth(temp_mean, precip, pet)  # kg/m\u00b2/yr\n            npp_flux = npp_annual / (365 * 24 * 3600)  # kg/m\u00b2/s\n\n            # Calculate E_BIO [W/m\u00b2]\n            h_BIO = 22e6  # J/kg\n            E_BIO = npp_flux * h_BIO\n\n            # Calculate EEMT [W/m\u00b2]\n            eemt_flux = np.mean(E_BIO + E_PPT)  # Average over months\n\n            # Convert to MJ/m\u00b2/yr\n            eemt_result[i, j] = eemt_flux * 365 * 24 * 3600 / 1e6\n\n    return eemt_result\n\n# Example usage\ndef run_traditional_workflow(dem_file, climate_dir, output_file):\n    \"\"\"Complete traditional EEMT workflow\"\"\"\n\n    # Load climate data (assumes NetCDF format)\n    import xarray as xr\n\n    # Load DAYMET data\n    tmin = xr.open_dataset(f\"{climate_dir}/tmin_monthly.nc\")\n    tmax = xr.open_dataset(f\"{climate_dir}/tmax_monthly.nc\") \n    precip = xr.open_dataset(f\"{climate_dir}/prcp_monthly.nc\")\n\n    # Calculate mean temperature\n    tmean = (tmin + tmax) / 2\n\n    # Calculate daylight hours (simplified)\n    # This should use actual solar geometry calculations\n    daylight_hours = np.full_like(tmean, 12.0)  # Placeholder\n\n    # Prepare data arrays\n    temp_data = {\n        'tmean': tmean.values,\n        'tmax': tmax.values, \n        'tmin': tmin.values\n    }\n\n    # Calculate EEMT\n    eemt = calculate_eemt_traditional(temp_data, precip.values, daylight_hours)\n\n    # Save results\n    with rasterio.open(dem_file) as dem_src:\n        profile = dem_src.profile.copy()\n        profile.update(dtype='float32', count=1)\n\n        with rasterio.open(output_file, 'w', **profile) as dst:\n            dst.write(eemt.astype(np.float32), 1)\n\n    print(f\"Traditional EEMT saved to: {output_file}\")\n\n# Run workflow\n# run_traditional_workflow('dem.tif', 'climate_data/', 'eemt_traditional.tif')\n</code></pre>"},{"location":"workflows/#workflow-2-topographic-eemt-eemt_topo","title":"Workflow 2: Topographic EEMT (EEMT_TOPO)","text":""},{"location":"workflows/#overview_2","title":"Overview","text":"<p>Incorporates topographic controls on solar radiation, temperature, and water redistribution.</p>"},{"location":"workflows/#enhanced-implementation","title":"Enhanced Implementation","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nTopographic EEMT Calculation\nBased on Rasmussen et al. (2014) methodology\n\"\"\"\n\nimport numpy as np\nimport rasterio\nimport subprocess\nimport tempfile\nimport os\nfrom pathlib import Path\n\nclass TopographicEEMT:\n    \"\"\"Calculate EEMT with topographic controls\"\"\"\n\n    def __init__(self, dem_path, climate_dir, output_dir):\n        self.dem_path = Path(dem_path)\n        self.climate_dir = Path(climate_dir)\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n\n    def calculate_solar_radiation(self):\n        \"\"\"Calculate topographically-modified solar radiation\"\"\"\n\n        # Run annual solar radiation calculation\n        from grass_solar_calculator import GrassSolarCalculator\n\n        solar_calc = GrassSolarCalculator(\n            str(self.dem_path), \n            str(self.output_dir / 'solar')\n        )\n\n        # Calculate for full year\n        solar_calc.calculate_annual_solar()\n        solar_calc.calculate_monthly_summaries()\n\n        print(\"\u2713 Solar radiation calculation completed\")\n\n    def calculate_topographic_temperature(self, base_temp, lapse_rate=-6.5):\n        \"\"\"\n        Calculate topographically-modified temperature\n        Following Eq. 6 from Rasmussen et al. (2014)\n        \"\"\"\n\n        with rasterio.open(self.dem_path) as dem_src:\n            elevation = dem_src.read(1)\n            profile = dem_src.profile\n\n        # Load solar radiation ratio (S_topo / S_flat)\n        solar_ratio_file = self.output_dir / 'solar' / 'solar_ratio_annual.tif'\n\n        if solar_ratio_file.exists():\n            with rasterio.open(solar_ratio_file) as src:\n                solar_ratio = src.read(1)\n        else:\n            print(\"Warning: Solar ratio not found, using elevation only\")\n            solar_ratio = np.ones_like(elevation)\n\n        # Calculate temperature modification\n        # T_i = T_b - T_lapse * (z_i - z_b)/1000 + C * (S_i - 1/S_i) * (1 - LAI_i/LAI_max)\n\n        base_elevation = np.nanmin(elevation)\n        elevation_diff = (elevation - base_elevation) / 1000  # km\n\n        # Temperature lapse rate effect\n        temp_lapse_effect = lapse_rate * elevation_diff\n\n        # Solar radiation effect (simplified - no LAI for TOPO method)\n        solar_effect = 2.0 * (solar_ratio - 1/solar_ratio)  # C=2 constant\n\n        # Modified temperature\n        temp_modified = base_temp - temp_lapse_effect + solar_effect\n\n        return temp_modified, profile\n\n    def calculate_mcwi(self):\n        \"\"\"\n        Calculate Mass Conservative Wetness Index\n        Following Rasmussen et al. (2014) Eq. 9-10\n        \"\"\"\n\n        # Use GRASS to calculate flow accumulation and slope\n        temp_location = tempfile.mkdtemp()\n\n        grass_commands = f\"\"\"\n# Import DEM\nr.in.gdal input={self.dem_path} output=dem\n\n# Calculate flow accumulation using D-infinity\nr.terraflow elevation=dem filled=dem_filled direction=flow_dir \\\\\n            swatershed=watersheds accumulation=flow_accum tci=twi\n\n# Calculate slope in degrees\nr.slope.aspect elevation=dem slope=slope_deg\n\n# Calculate traditional wetness index  \nr.mapcalc \"wetness_index = log(flow_accum / tan(slope_deg * 3.14159/180))\"\n\n# Calculate mass conservative wetness index (MCWI)\n# Normalize by mean wetness index to conserve mass\nr.univar wetness_index\n\"\"\"\n\n        # Execute GRASS commands and calculate MCWI\n        # (Implementation details for MCWI calculation)\n\n        return self.output_dir / 'mcwi.tif'\n\n    def calculate_effective_precipitation(self, precipitation, temperature):\n        \"\"\"\n        Calculate effective precipitation with topographic redistribution\n        Using Penman-Monteith and Budyko curve approach\n        \"\"\"\n\n        # Load MCWI for water redistribution\n        with rasterio.open(self.output_dir / 'mcwi.tif') as src:\n            mcwi = src.read(1)\n\n        # Calculate PET using Penman-Monteith (simplified)\n        # This is a placeholder - full implementation needs wind, humidity, radiation\n        pet = self.calculate_penman_monteith(temperature, precipitation)\n\n        # Calculate AET using Budyko curve\n        aridity_index = pet / precipitation\n        w = 2.63  # Empirical constant\n\n        # Zhang-Budyko equation\n        aet_ratio = (1 + w * aridity_index) / (1 + w * aridity_index + 1/aridity_index)\n        aet = precipitation * aet_ratio\n\n        # Effective precipitation\n        effective_precip = precipitation - aet\n\n        # Redistribute using MCWI\n        effective_precip_redistributed = effective_precip * mcwi\n\n        return effective_precip_redistributed\n\n    def calculate_npp_topographic(self, elevation, aspect, slope):\n        \"\"\"\n        Calculate NPP with topographic controls\n        Following Eq. 11 from Rasmussen et al. (2014)\n        \"\"\"\n\n        # Calculate northness\n        aspect_rad = np.deg2rad(aspect)\n        slope_rad = np.deg2rad(slope)\n        northness = np.cos(aspect_rad) * np.sin(slope_rad)\n\n        # Empirical relationship from Whittaker and Niering (1975)\n        # NPP = 0.39z + 346n - 187 [g/m\u00b2/yr]\n        npp = 0.39 * elevation + 346 * northness - 187\n\n        # Set minimum NPP\n        npp = np.maximum(npp, 100)  # g/m\u00b2/yr minimum\n\n        # Convert to kg/m\u00b2/yr\n        npp_kg = npp / 1000\n\n        return npp_kg\n\n    def run_complete_workflow(self):\n        \"\"\"Execute complete topographic EEMT workflow\"\"\"\n\n        print(\"Starting Topographic EEMT Calculation...\")\n\n        # Step 1: Calculate solar radiation\n        print(\"1. Calculating solar radiation...\")\n        self.calculate_solar_radiation()\n\n        # Step 2: Calculate MCWI\n        print(\"2. Calculating mass conservative wetness index...\")\n        mcwi_file = self.calculate_mcwi()\n\n        # Step 3: Load climate data and DEM\n        print(\"3. Loading input data...\")\n        with rasterio.open(self.dem_path) as src:\n            elevation = src.read(1)\n            profile = src.profile\n\n        # Load climate data (implementation depends on data format)\n        # This is a placeholder for actual climate data loading\n        climate_data = self.load_climate_data()\n\n        # Step 4: Calculate topographically modified temperature\n        print(\"4. Calculating topographic temperature modification...\")\n        temp_modified, _ = self.calculate_topographic_temperature(\n            climate_data['temperature'], \n            lapse_rate=-6.5\n        )\n\n        # Step 5: Calculate effective precipitation with redistribution\n        print(\"5. Calculating effective precipitation...\")\n        effective_precip = self.calculate_effective_precipitation(\n            climate_data['precipitation'],\n            temp_modified\n        )\n\n        # Step 6: Calculate NPP with topographic effects\n        print(\"6. Calculating topographic NPP...\")\n\n        # Load slope and aspect from DEM\n        slope, aspect = self.calculate_slope_aspect()\n        npp = self.calculate_npp_topographic(elevation, aspect, slope)\n\n        # Step 7: Calculate EEMT components\n        print(\"7. Calculating EEMT components...\")\n\n        # E_BIO calculation\n        h_bio = 22e6  # J/kg\n        npp_flux = npp / (365 * 24 * 3600)  # kg/m\u00b2/s\n        e_bio = npp_flux * h_bio  # W/m\u00b2\n\n        # E_PPT calculation  \n        c_w = 4180  # J/kg/K\n        delta_t = np.maximum(0, temp_modified - 273.15)  # K above freezing\n        precip_flux = effective_precip / (30.4 * 24 * 3600)  # kg/m\u00b2/s (monthly avg)\n        e_ppt = precip_flux * c_w * delta_t  # W/m\u00b2\n\n        # Calculate EEMT\n        eemt_flux = e_bio + e_ppt  # W/m\u00b2\n        eemt_annual = eemt_flux * 365 * 24 * 3600 / 1e6  # MJ/m\u00b2/yr\n\n        # Step 8: Save results\n        print(\"8. Saving results...\")\n\n        # Save EEMT\n        with rasterio.open(self.output_dir / 'eemt_topographic.tif', 'w', **profile) as dst:\n            dst.write(eemt_annual.astype(np.float32), 1)\n\n        # Save components\n        with rasterio.open(self.output_dir / 'e_bio_topographic.tif', 'w', **profile) as dst:\n            dst.write((e_bio * 365 * 24 * 3600 / 1e6).astype(np.float32), 1)\n\n        with rasterio.open(self.output_dir / 'e_ppt_topographic.tif', 'w', **profile) as dst:\n            dst.write((e_ppt * 365 * 24 * 3600 / 1e6).astype(np.float32), 1)\n\n        print(f\"\u2713 Topographic EEMT calculation completed\")\n        print(f\"Results saved to: {self.output_dir}\")\n\n        return eemt_annual\n\n# Usage example\nif __name__ == '__main__':\n\n    # Initialize calculator\n    calculator = TopographicEEMT(\n        dem_path='data/elevation/dem.tif',\n        climate_dir='data/climate/',\n        output_dir='results/eemt_topographic/'\n    )\n\n    # Run complete workflow\n    eemt_result = calculator.run_complete_workflow()\n\n    # Print summary statistics\n    print(f\"\\nEEMT Summary Statistics:\")\n    print(f\"  Mean: {np.nanmean(eemt_result):.2f} MJ/m\u00b2/yr\")\n    print(f\"  Min:  {np.nanmin(eemt_result):.2f} MJ/m\u00b2/yr\") \n    print(f\"  Max:  {np.nanmax(eemt_result):.2f} MJ/m\u00b2/yr\")\n    print(f\"  Std:  {np.nanstd(eemt_result):.2f} MJ/m\u00b2/yr\")\n</code></pre>"},{"location":"workflows/#workflow-3-vegetation-eemt-eemt_topo-veg","title":"Workflow 3: Vegetation EEMT (EEMT_TOPO-VEG)","text":""},{"location":"workflows/#overview_3","title":"Overview","text":"<p>Full implementation including vegetation structure, LAI, and surface resistance effects.</p>"},{"location":"workflows/#implementation_1","title":"Implementation","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nVegetation-Enhanced EEMT Calculation  \nBased on Rasmussen et al. (2014) EEMT_TOPO-VEG approach\n\"\"\"\n\nimport numpy as np\nimport rasterio\nfrom scipy import ndimage\n\nclass VegetationEEMT(TopographicEEMT):\n    \"\"\"EEMT calculation with full vegetation integration\"\"\"\n\n    def __init__(self, dem_path, climate_dir, output_dir, vegetation_data=None):\n        super().__init__(dem_path, climate_dir, output_dir)\n        self.vegetation_data = vegetation_data\n\n    def calculate_lai_from_ndvi(self, ndvi_file):\n        \"\"\"\n        Calculate Leaf Area Index from NDVI\n        Using Qi et al. (2000) polynomial for semiarid regions\n        \"\"\"\n\n        with rasterio.open(ndvi_file) as src:\n            ndvi = src.read(1)\n            profile = src.profile\n\n        # Qi et al. (2000) polynomial: LAI = ax\u00b3 + bx\u00b2 + cx + d\n        a, b, c, d = 18.99, -15.24, 6.124, -0.352\n        lai = a * ndvi**3 + b * ndvi**2 + c * ndvi + d\n\n        # Constrain LAI to reasonable range\n        lai = np.clip(lai, 0, 10)\n\n        # Save LAI\n        lai_file = self.output_dir / 'lai.tif'\n        with rasterio.open(lai_file, 'w', **profile) as dst:\n            dst.write(lai.astype(np.float32), 1)\n\n        return lai, lai_file\n\n    def calculate_canopy_height_from_lidar(self, lidar_file):\n        \"\"\"\n        Extract canopy height from LiDAR data\n        \"\"\"\n\n        # This would process LiDAR point clouds or canopy height models\n        # For now, return placeholder based on LAI\n        with rasterio.open(self.output_dir / 'lai.tif') as src:\n            lai = src.read(1)\n            profile = src.profile\n\n        # Estimate canopy height from LAI (simplified relationship)\n        # In practice, use actual LiDAR processing\n        canopy_height = lai * 2.5  # Rough approximation\n\n        # Save canopy height\n        height_file = self.output_dir / 'canopy_height.tif'\n        with rasterio.open(height_file, 'w', **profile) as dst:\n            dst.write(canopy_height.astype(np.float32), 1)\n\n        return canopy_height, height_file\n\n    def calculate_npp_vegetation(self, canopy_height):\n        \"\"\"\n        Calculate NPP from canopy height\n        Following Eq. 12 from Rasmussen et al. (2014)\n        \"\"\"\n\n        # Polynomial relationship: NPP = 196 + 36h - 0.61h\u00b2 - 12.09h\u00b3\n        h = canopy_height\n        npp = 196 + 36*h - 0.61*h**2 - 12.09*h**3\n\n        # Set minimum NPP\n        npp = np.maximum(npp, 100)  # g/m\u00b2/yr\n\n        # Convert to kg/m\u00b2/yr\n        npp_kg = npp / 1000\n\n        return npp_kg\n\n    def calculate_surface_resistance(self, lai):\n        \"\"\"\n        Calculate surface resistance from LAI\n        Following Schulze et al. (1994) and Kelliher et al. (1995)\n        \"\"\"\n\n        # Maximum leaf stomatal conductance \n        g_max = 0.008  # m/s\n\n        # Bulk surface conductance from LAI\n        # Polynomial fit to literature data\n        g_surface = g_max * (1 - np.exp(-0.5 * lai))\n\n        # Surface resistance (inverse of conductance)\n        r_surface = 1 / np.maximum(g_surface, 1e-6)  # Avoid division by zero\n\n        # Constrain to reasonable range\n        r_surface = np.clip(r_surface, 38, 1000)  # s/m\n\n        return r_surface\n\n    def calculate_aet_penman_monteith(self, temperature, humidity, wind_speed, \n                                    net_radiation, lai):\n        \"\"\"\n        Calculate actual evapotranspiration using full Penman-Monteith\n        Including surface and aerodynamic resistance\n        \"\"\"\n\n        # Calculate surface resistance\n        r_surface = self.calculate_surface_resistance(lai)\n\n        # Calculate aerodynamic resistance (simplified)\n        # In practice, use canopy height and wind profile\n        canopy_height = lai * 2.0  # Rough estimate\n        r_aero = 208 / np.maximum(wind_speed, 0.1) * np.log(2.0 / (0.1 * canopy_height))\n        r_aero = np.clip(r_aero, 10, 500)  # s/m\n\n        # Psychrometric constant\n        gamma = 0.665  # kPa/\u00b0C\n\n        # Slope of saturation vapor pressure curve\n        delta = 4098 * (0.6108 * np.exp(17.27 * temperature / (temperature + 237.3))) / (temperature + 237.3)**2\n\n        # Vapor pressure deficit\n        es = 0.6108 * np.exp(17.27 * temperature / (temperature + 237.3))\n        ea = humidity * es / 100  # Assuming humidity is relative humidity %\n        vpd = es - ea\n\n        # Penman-Monteith equation\n        numerator = delta * net_radiation + gamma * 900 * vpd / (temperature + 273) / r_aero\n        denominator = delta + gamma * (1 + r_surface / r_aero)\n\n        aet = numerator / denominator  # mm/day\n\n        return aet\n\n    def run_vegetation_workflow(self, ndvi_file=None, lidar_file=None):\n        \"\"\"Execute complete vegetation EEMT workflow\"\"\"\n\n        print(\"Starting Vegetation EEMT Calculation...\")\n\n        # Step 1: Calculate solar radiation (inherited)\n        print(\"1. Calculating solar radiation...\")\n        self.calculate_solar_radiation()\n\n        # Step 2: Process vegetation data\n        print(\"2. Processing vegetation data...\")\n\n        if ndvi_file:\n            lai, lai_file = self.calculate_lai_from_ndvi(ndvi_file)\n        else:\n            print(\"Warning: No NDVI data provided, using default LAI\")\n            lai = np.ones((100, 100)) * 2.0  # Placeholder\n\n        if lidar_file:\n            canopy_height, height_file = self.calculate_canopy_height_from_lidar(lidar_file)\n        else:\n            canopy_height, height_file = self.calculate_canopy_height_from_lidar(None)\n\n        # Step 3: Calculate vegetation-modified NPP\n        print(\"3. Calculating vegetation NPP...\")\n        npp = self.calculate_npp_vegetation(canopy_height)\n\n        # Step 4: Calculate AET with vegetation effects\n        print(\"4. Calculating AET with vegetation controls...\")\n\n        # Load climate data\n        climate_data = self.load_climate_data()\n\n        # Calculate AET using Penman-Monteith with vegetation resistance\n        aet = self.calculate_aet_penman_monteith(\n            climate_data['temperature'],\n            climate_data['humidity'], \n            climate_data['wind_speed'],\n            climate_data['net_radiation'],\n            lai\n        )\n\n        # Step 5: Calculate effective precipitation\n        effective_precip = climate_data['precipitation'] - aet\n\n        # Step 6: Apply topographic redistribution\n        with rasterio.open(self.output_dir / 'mcwi.tif') as src:\n            mcwi = src.read(1)\n\n        effective_precip_redistributed = effective_precip * mcwi\n\n        # Step 7: Calculate EEMT\n        print(\"5. Calculating final EEMT...\")\n\n        # Load DEM for output profile\n        with rasterio.open(self.dem_path) as src:\n            profile = src.profile\n\n        # Energy calculations\n        h_bio = 22e6  # J/kg\n        c_w = 4180   # J/kg/K\n\n        # Convert fluxes to W/m\u00b2\n        npp_flux = npp / (365 * 24 * 3600)  # kg/m\u00b2/s\n        precip_flux = effective_precip_redistributed / (30.4 * 24 * 3600)  # kg/m\u00b2/s\n\n        # Energy components\n        e_bio = npp_flux * h_bio\n        e_ppt = precip_flux * c_w * np.maximum(0, climate_data['temperature'] - 273.15)\n\n        # Total EEMT\n        eemt_flux = e_bio + e_ppt\n        eemt_annual = eemt_flux * 365 * 24 * 3600 / 1e6  # MJ/m\u00b2/yr\n\n        # Step 8: Save results\n        print(\"6. Saving results...\")\n\n        outputs = {\n            'eemt_vegetation.tif': eemt_annual,\n            'e_bio_vegetation.tif': e_bio * 365 * 24 * 3600 / 1e6,\n            'e_ppt_vegetation.tif': e_ppt * 365 * 24 * 3600 / 1e6,\n            'npp_vegetation.tif': npp,\n            'lai.tif': lai,\n            'canopy_height.tif': canopy_height\n        }\n\n        for filename, data in outputs.items():\n            output_path = self.output_dir / filename\n            with rasterio.open(output_path, 'w', **profile) as dst:\n                dst.write(data.astype(np.float32), 1)\n\n        print(f\"\u2713 Vegetation EEMT calculation completed\")\n        print(f\"Results saved to: {self.output_dir}\")\n\n        return eemt_annual\n\n# Command line interface\nif __name__ == '__main__':\n    import argparse\n\n    parser = argparse.ArgumentParser(description='Vegetation EEMT Calculator')\n    parser.add_argument('dem', help='Input DEM file')\n    parser.add_argument('--climate-dir', required=True, help='Climate data directory')\n    parser.add_argument('--output-dir', required=True, help='Output directory')\n    parser.add_argument('--ndvi', help='NDVI raster file for LAI calculation')\n    parser.add_argument('--lidar', help='LiDAR file for canopy height')\n\n    args = parser.parse_args()\n\n    # Run vegetation EEMT calculation\n    calculator = VegetationEEMT(args.dem, args.climate_dir, args.output_dir)\n    result = calculator.run_vegetation_workflow(args.ndvi, args.lidar)\n\n    print(f\"Vegetation EEMT range: {np.nanmin(result):.1f} - {np.nanmax(result):.1f} MJ/m\u00b2/yr\")\n</code></pre>"},{"location":"workflows/#automated-workflow-integration","title":"Automated Workflow Integration","text":""},{"location":"workflows/#complete-eemt-pipeline","title":"Complete EEMT Pipeline","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nComplete EEMT calculation pipeline integrating all three approaches\nEnhanced version of eemt/run-workflow\n\"\"\"\n\nimport argparse\nimport sys\nfrom pathlib import Path\nimport numpy as np\nimport rasterio\n\ndef run_complete_eemt_pipeline(dem_file, output_dir, climate_dir, \n                             start_year=2015, end_year=2020,\n                             vegetation_data=None, validation_data=None):\n    \"\"\"\n    Run complete EEMT pipeline with all three calculation methods\n\n    Parameters:\n    dem_file: Path to elevation data\n    output_dir: Output directory for results\n    climate_dir: Directory containing climate data\n    start_year, end_year: Analysis time period\n    vegetation_data: Dict with 'ndvi' and 'lidar' file paths\n    validation_data: Dict with validation datasets (soil depth, biomass, etc.)\n    \"\"\"\n\n    print(\"=== EEMT Complete Pipeline ===\")\n\n    output_dir = Path(output_dir) \n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    results = {}\n\n    # Method 1: Traditional EEMT\n    print(\"\\n1. Calculating Traditional EEMT...\")\n\n    try:\n        eemt_trad = run_traditional_workflow(\n            dem_file, \n            climate_dir, \n            output_dir / 'eemt_traditional.tif'\n        )\n        results['traditional'] = eemt_trad\n        print(\"\u2713 Traditional EEMT completed\")\n    except Exception as e:\n        print(f\"\u2717 Traditional EEMT failed: {e}\")\n\n    # Method 2: Topographic EEMT  \n    print(\"\\n2. Calculating Topographic EEMT...\")\n\n    try:\n        topo_calculator = TopographicEEMT(dem_file, climate_dir, output_dir / 'topographic')\n        eemt_topo = topo_calculator.run_complete_workflow()\n        results['topographic'] = eemt_topo\n        print(\"\u2713 Topographic EEMT completed\")\n    except Exception as e:\n        print(f\"\u2717 Topographic EEMT failed: {e}\")\n\n    # Method 3: Vegetation EEMT\n    print(\"\\n3. Calculating Vegetation EEMT...\")\n\n    try:\n        veg_calculator = VegetationEEMT(\n            dem_file, climate_dir, output_dir / 'vegetation',\n            vegetation_data\n        )\n\n        ndvi_file = vegetation_data.get('ndvi') if vegetation_data else None\n        lidar_file = vegetation_data.get('lidar') if vegetation_data else None\n\n        eemt_veg = veg_calculator.run_vegetation_workflow(ndvi_file, lidar_file)\n        results['vegetation'] = eemt_veg\n        print(\"\u2713 Vegetation EEMT completed\")\n    except Exception as e:\n        print(f\"\u2717 Vegetation EEMT failed: {e}\")\n\n    # Comparison Analysis\n    print(\"\\n4. Generating Comparison Analysis...\")\n\n    if len(results) &gt; 1:\n        generate_comparison_analysis(results, output_dir / 'comparison')\n\n    # Validation (if data provided)\n    if validation_data:\n        print(\"\\n5. Running Validation Analysis...\")\n        run_validation_analysis(results, validation_data, output_dir / 'validation')\n\n    print(f\"\\n=== Pipeline Complete ===\")\n    print(f\"Results saved to: {output_dir}\")\n\n    return results\n\ndef generate_comparison_analysis(results, output_dir):\n    \"\"\"Generate comparison plots and statistics between EEMT methods\"\"\"\n\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    # Load first result to get spatial structure\n    first_key = list(results.keys())[0]\n\n    if isinstance(results[first_key], str):\n        # Results are file paths\n        comparison_data = {}\n        for method, filepath in results.items():\n            with rasterio.open(filepath) as src:\n                comparison_data[method] = src.read(1)\n                profile = src.profile\n    else:\n        # Results are arrays\n        comparison_data = results\n\n    # Calculate difference maps\n    if 'traditional' in comparison_data and 'topographic' in comparison_data:\n        diff_topo_trad = comparison_data['topographic'] - comparison_data['traditional']\n\n        with rasterio.open(output_dir / 'difference_topo_minus_trad.tif', 'w', **profile) as dst:\n            dst.write(diff_topo_trad.astype(np.float32), 1)\n\n    if 'vegetation' in comparison_data and 'topographic' in comparison_data:\n        diff_veg_topo = comparison_data['vegetation'] - comparison_data['topographic'] \n\n        with rasterio.open(output_dir / 'difference_veg_minus_topo.tif', 'w', **profile) as dst:\n            dst.write(diff_veg_topo.astype(np.float32), 1)\n\n    # Summary statistics\n    stats_file = output_dir / 'comparison_statistics.txt'\n    with open(stats_file, 'w') as f:\n        f.write(\"EEMT Method Comparison Statistics\\\\n\")\n        f.write(\"=\" * 40 + \"\\\\n\\\\n\")\n\n        for method, data in comparison_data.items():\n            f.write(f\"{method.upper()} EEMT:\\\\n\")\n            f.write(f\"  Mean: {np.nanmean(data):.2f} MJ/m\u00b2/yr\\\\n\")\n            f.write(f\"  Std:  {np.nanstd(data):.2f} MJ/m\u00b2/yr\\\\n\")\n            f.write(f\"  Min:  {np.nanmin(data):.2f} MJ/m\u00b2/yr\\\\n\")\n            f.write(f\"  Max:  {np.nanmax(data):.2f} MJ/m\u00b2/yr\\\\n\\\\n\")\n\n    print(f\"\u2713 Comparison analysis saved to: {output_dir}\")\n\ndef main():\n    \"\"\"Main command line interface\"\"\"\n\n    parser = argparse.ArgumentParser(description='Complete EEMT Pipeline')\n    parser.add_argument('dem', help='Input DEM file path')\n    parser.add_argument('--output', '-o', required=True, help='Output directory')\n    parser.add_argument('--climate', '-c', required=True, help='Climate data directory')\n    parser.add_argument('--start-year', type=int, default=2015, help='Start year')\n    parser.add_argument('--end-year', type=int, default=2020, help='End year')\n    parser.add_argument('--ndvi', help='NDVI file for vegetation analysis')\n    parser.add_argument('--lidar', help='LiDAR file for canopy height')\n    parser.add_argument('--validation-soil', help='Soil depth data for validation')\n    parser.add_argument('--validation-biomass', help='Biomass data for validation')\n\n    args = parser.parse_args()\n\n    # Prepare vegetation data\n    vegetation_data = {}\n    if args.ndvi:\n        vegetation_data['ndvi'] = args.ndvi\n    if args.lidar:\n        vegetation_data['lidar'] = args.lidar\n\n    # Prepare validation data  \n    validation_data = {}\n    if args.validation_soil:\n        validation_data['soil_depth'] = args.validation_soil\n    if args.validation_biomass:\n        validation_data['biomass'] = args.validation_biomass\n\n    # Run complete pipeline\n    results = run_complete_eemt_pipeline(\n        args.dem,\n        args.output,\n        args.climate,\n        args.start_year,\n        args.end_year,\n        vegetation_data if vegetation_data else None,\n        validation_data if validation_data else None\n    )\n\n    # Success summary\n    success_count = len(results)\n    print(f\"\\\\nPipeline completed with {success_count}/3 methods successful\")\n\n    return success_count &gt; 0\n\nif __name__ == '__main__':\n    success = main()\n    sys.exit(0 if success else 1)\n</code></pre>"},{"location":"workflows/#integration-with-public-data-sources","title":"Integration with Public Data Sources","text":""},{"location":"workflows/#automated-data-acquisition-pipeline","title":"Automated Data Acquisition Pipeline","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nAutomated data acquisition for EEMT calculations\nIntegrates with public data sources\n\"\"\"\n\nfrom data_sources.elevation import download_3dep, download_opentopo\nfrom data_sources.climate import download_daymet_spatial, download_prism\nfrom data_sources.satellite import download_landsat_ndvi\n\ndef setup_eemt_project(study_area, years, project_dir):\n    \"\"\"\n    Automated setup of complete EEMT project with public data\n\n    Parameters:\n    study_area: [west, south, east, north] bounding box\n    years: [start_year, end_year] \n    project_dir: output directory\n    \"\"\"\n\n    project_dir = Path(project_dir)\n    project_dir.mkdir(parents=True, exist_ok=True)\n\n    print(f\"Setting up EEMT project for {study_area}\")\n    print(f\"Time period: {years[0]}-{years[1]}\")\n    print(f\"Project directory: {project_dir}\")\n\n    # 1. Download elevation data\n    print(\"\\\\n1. Downloading elevation data...\")\n    dem_file = download_3dep(study_area, resolution='10m')\n    # Fallback to global data if US data unavailable  \n    if not dem_file:\n        dem_file = download_opentopo(study_area, 'SRTMGL1')\n\n    # 2. Download climate data\n    print(\"\\\\n2. Downloading climate data...\")\n    climate_files = download_daymet_spatial(\n        study_area, range(years[0], years[1]+1), \n        ['tmin', 'tmax', 'prcp', 'vp']\n    )\n\n    # 3. Download vegetation data\n    print(\"\\\\n3. Downloading vegetation data...\")\n    ndvi_file = download_landsat_ndvi(study_area, years[0])\n\n    # 4. Set up analysis directories\n    print(\"\\\\n4. Setting up analysis structure...\")\n\n    analysis_config = {\n        'dem_file': dem_file,\n        'climate_dir': project_dir / 'climate',\n        'vegetation_data': {'ndvi': ndvi_file},\n        'output_dir': project_dir / 'results'\n    }\n\n    # Save configuration\n    import json\n    with open(project_dir / 'eemt_config.json', 'w') as f:\n        json.dump(analysis_config, f, indent=2, default=str)\n\n    print(\"\\\\n\u2713 Project setup completed!\")\n    print(f\"Configuration saved to: {project_dir}/eemt_config.json\")\n    print(f\"Run analysis with: python run_complete_eemt.py {project_dir}/eemt_config.json\")\n\n    return analysis_config\n\n# Example usage\nif __name__ == '__main__':\n\n    # Arizona Sky Islands study area\n    bbox = [-111.0, 32.0, -110.0, 32.5]\n    years = [2015, 2020]\n\n    config = setup_eemt_project(bbox, years, 'arizona_eemt_project')\n</code></pre> <p>This comprehensive workflow documentation provides the foundation for modern EEMT calculations using public datasets and open-source tools, with significant improvements in parallel processing and computational efficiency over the original 2016 implementation.</p>"}]}